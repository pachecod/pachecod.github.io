{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BabylonML BabylonML makes creating 3D web experiences easier by providing HTML-like tags to control the powerful Babylon.js engine. Instead of writing complex JavaScript setup code, you can define your scene declaratively: <bml-scene> <bml-entity id=\"my-box\" position=\"0 1 -3\" rotation=\"0 45 0\" geometry=\"type: box; width: 1; height: 1; depth: 1\" material=\"type: standard; diffuseColor: #FF0000\"> </bml-entity> <bml-entity id=\"ground\" position=\"0 0 -3\" geometry=\"type: ground; width: 5; height: 5\" material=\"type: standard; diffuseColor: #444444\"> </bml-entity> </bml-scene> \u27a1\ufe0f View Live Examples Key Concepts <bml-scene> : The root element that initializes the Babylon.js engine and scene. <bml-entity> : Represents an object or node within the 3D scene. Think of it like a div for 3D. Components: Attributes like position , rotation , geometry , and material that define the properties and behavior of an entity. Getting Started (Documentation on installation and basic usage will go here) Next Steps This documentation is just getting started. Future sections will cover: Detailed installation instructions. In-depth explanations of core concepts ( <bml-scene> , <bml-entity> , Component System). Reference guides for all built-in components. Examples of common use cases. How to create custom components.","title":"Home"},{"location":"#welcome-to-babylonml","text":"BabylonML makes creating 3D web experiences easier by providing HTML-like tags to control the powerful Babylon.js engine. Instead of writing complex JavaScript setup code, you can define your scene declaratively: <bml-scene> <bml-entity id=\"my-box\" position=\"0 1 -3\" rotation=\"0 45 0\" geometry=\"type: box; width: 1; height: 1; depth: 1\" material=\"type: standard; diffuseColor: #FF0000\"> </bml-entity> <bml-entity id=\"ground\" position=\"0 0 -3\" geometry=\"type: ground; width: 5; height: 5\" material=\"type: standard; diffuseColor: #444444\"> </bml-entity> </bml-scene> \u27a1\ufe0f View Live Examples","title":"Welcome to BabylonML"},{"location":"#key-concepts","text":"<bml-scene> : The root element that initializes the Babylon.js engine and scene. <bml-entity> : Represents an object or node within the 3D scene. Think of it like a div for 3D. Components: Attributes like position , rotation , geometry , and material that define the properties and behavior of an entity.","title":"Key Concepts"},{"location":"#getting-started","text":"(Documentation on installation and basic usage will go here)","title":"Getting Started"},{"location":"#next-steps","text":"This documentation is just getting started. Future sections will cover: Detailed installation instructions. In-depth explanations of core concepts ( <bml-scene> , <bml-entity> , Component System). Reference guides for all built-in components. Examples of common use cases. How to create custom components.","title":"Next Steps"},{"location":"examples/","text":"Live Examples This page provides links to live, hosted examples demonstrating various features of BabylonML. These examples are hosted separately and load the latest version of the BabylonML library. Basic Scene Demonstrates a simple scene with a box, ground, and default camera/light. Includes dynamic material update via JavaScript. ```html <!DOCTYPE html> BabylonML - Local Test /<em> Basic styling to make the scene visible </em>/ html, body { margin: 0; padding: 0; overflow: hidden; /<em> Prevent scrollbars </em>/ height: 100%; width: 100%; } bml-scene { width: 100vw; /<em> Viewport width </em>/ height: 100vh; /<em> Viewport height </em>/ display: block; /<em> Make it a block element </em>/ } canvas { display: block; /<em> Prevent potential small gap below canvas </em>/ } <!-- A ground plane --> <bml-entity geometry=\"type: ground; width: 10; height: 10\" material=\"color: #8FBC8F\"> <!-- Position defaults to 0 0 0 --> </bml-entity> // Optional: You can add JavaScript here to interact with the scene // after it's potentially ready. const sceneEl = document.querySelector('bml-scene');</p> <pre><code> // Check if the scene is already ready when the script runs if (sceneEl &amp;&amp; sceneEl.isReady) { console.log(\"DEBUG: Scene was already ready. Running setup directly.\"); babylonScene = sceneEl.babylonScene; // Get scene reference directly console.log(\"DEBUG: babylonScene reference obtained. \", babylonScene); // lets change the color of the box to blue const box = document.getElementById('my-box'); if (box) { console.log('Attempting to change box color via attribute...'); box.setAttribute('material', 'color: #0000FF'); // Change color to blue } } else if (sceneEl) { console.log(\"DEBUG: Scene not ready yet. Adding event listener.\"); sceneEl.addEventListener('bml-scene-ready', (event) =&gt; { console.log(\"DEBUG: bml-scene-ready event fired!\"); // &lt;-- Log event firing babylonScene = event.detail.scene; consoler.log(\"DEBUG: babylonScene reference obtained. \", babylonScene); // Example: Simple interaction after a delay setTimeout(() =&gt; { const box = document.getElementById('my-box'); if (box) { console.log('Attempting to change box color via attribute...'); box.setAttribute('material', 'color: #0000FF'); // Change color to blue } }, 5000); // After 5 seconds }); } // Example: Accessing BML global API (if implemented) if (window.BML) { console.log('BML Global API found:', BML); // Example: How a user might register their own component // BML.registerComponent('my-custom-spin', { ... }); } </code></pre> ``` Explicit Camera & Light Placeholder Shows how defining an explicit camera overrides the default, and how the (currently non-functional) light attribute placeholder prevents the default light. ```html <!DOCTYPE html> BabylonML Example: Explicit Camera & Light Placeholder html, body { margin: 0; padding: 0; overflow: hidden; /<em> Prevent scrollbars </em>/ height: 100%; width: 100%; } bml-scene { width: 100vw; /<em> Viewport width </em>/ height: 100vh; /<em> Viewport height </em>/ display: block; /<em> Ensure it behaves like a block element </em>/ } canvas { display: block; } <!-- Placeholder for a light source --> <!-- IMPORTANT: This disables the default light, but doesn't create a PointLight yet! --> <bml-entity id=\"myLightSource\" light=\"type: point; intensity: 0.8; position: 0 5 0\"> <!-- This entity currently does nothing visually --> </bml-entity> <!-- A simple box entity --> <bml-entity geometry=\"type: box; size: 1\" material=\"color: #FF6347\" <!-- Tomato color --> position=\"0 1 0\"> </bml-entity> <!-- A ground plane --> <bml-entity geometry=\"type: ground; width: 10; height: 10\" material=\"color: #B0C4DE\"> <!-- LightSteelBlue color --> </bml-entity> </bml-scene> <script> // Optional: Add a light programmatically since the component doesn't exist yet document.querySelector('bml-scene').addEventListener('bml-scene-ready', (event) => { const babylonScene = event.detail.scene; // Uncomment the lines below to add a light via JavaScript // console.log(\"Adding programmatic light...\"); // const pointLight = new BABYLON.PointLight(\"programmaticLight\", new BABYLON.Vector3(0, 5, 0), babylonScene); // pointLight.intensity = 0.8; // console.log(\"Programmatic light added.\"); }); </script> ``` Multiple Cameras Illustrates defining multiple cameras and switching between them using JavaScript. ```html <!DOCTYPE html> BabylonML Example: Multiple Cameras html, body { margin: 0; padding: 0; overflow: hidden; /<em> Prevent scrollbars </em>/ height: 100%; width: 100%; } bml-scene { width: 100vw; /<em> Viewport width </em>/ height: 100vh; /<em> Viewport height </em>/ display: block; /<em> Ensure it behaves like a block element </em>/ } canvas { display: block; } /<em> Style for the button </em>/ #switchCameraButton { position: absolute; top: 10px; left: 10px; padding: 10px 15px; font-size: 16px; cursor: pointer; z-index: 10; /<em> Ensure it's above the canvas </em>/ } Switch to Camera 2 <!-- This scene demonstrates defining multiple cameras. - The first camera entity encountered (\"camera1\", ArcRotate) will become the active camera by default. - The second camera (\"camera2\", Universal) will be created but inactive initially. - Click the button in the top-left corner to switch between them. - Since at least one camera is defined, the default FreeCamera is NOT created. - Since no light attribute is defined, the default HemisphericLight IS created. --> <bml-scene> <!-- First Camera (ArcRotate, active initially) --> <bml-entity id=\"camera1\" camera=\"type: arcRotate; alpha: -1.57; beta: 1.4; radius: 8; target: 0 1 0; attachControl: true\"> <!-- attachControl: true --> </bml-entity> <!-- Second Camera (Universal, inactive initially) --> <bml-entity id=\"camera2\" camera=\"type: universal; position: 5 2 5; target: 0 1 0; attachControl: false\"> <!-- attachControl: false --> </bml-entity> <!-- A simple box entity --> <bml-entity geometry=\"type: box; size: 1\" material=\"color: #6A5ACD\" <!-- SlateBlue color --> position=\"0 1 0\"> </bml-entity> <!-- A ground plane --> <bml-entity geometry=\"type: ground; width: 10; height: 10\" material=\"color: #98FB98\"> <!-- PaleGreen color --> </bml-entity> </bml-scene> <script> const sceneEl = document.querySelector('bml-scene'); const switchButton = document.getElementById('switchCameraButton'); let babylonScene = null; let canvas = null; let cam1 = null; // ArcRotate let cam2 = null; // Universal let cam1Attach = true; // Default based on attribute let cam2Attach = false; // Default based on attribute // Function to set up cameras and button once scene is ready function setupCameraSwitcher() { console.log(\"DEBUG: setupCameraSwitcher called.\"); if (!sceneEl.isReady || !babylonScene) { console.log(\"DEBUG: Scene not ready yet in setupCameraSwitcher.\"); return; // Should not happen if called correctly, but good check } canvas = sceneEl.babylonCanvas; // Get canvas reference from scene element // Add a small delay to ensure camera components have initialized AFTER scene is ready setTimeout(() => { console.log(\"DEBUG: setTimeout callback running...\"); // <-- Log timeout callback console.log(\"DEBUG: Available cameras:\", babylonScene.cameras.map(c => c.name)); // <-- Log available camera names // Get camera instances using their auto-generated names (check inspector if needed) cam1 = babylonScene.getCameraByName('camera1_arcRotateCamera'); cam2 = babylonScene.getCameraByName('camera2_universalCamera'); // Get camera entities to check original attachControl attribute const camEntity1 = document.getElementById('camera1'); const camEntity2 = document.getElementById('camera2'); // Store original attachControl settings (simple check) cam1Attach = (camEntity1?.getAttribute('camera') || '').includes('attachControl: true'); cam2Attach = (camEntity2?.getAttribute('camera') || '').includes('attachControl: true'); // Note: cam2 is false in HTML if (cam1 && cam2) { console.log(\"DEBUG: Cameras found by name:\", cam1.name, cam2.name); // <-- Log success console.log(\"Initial active camera:\", babylonScene.activeCamera.name); console.log(\"Camera 1 attachControl setting:\", cam1Attach); console.log(\"Camera 2 attachControl setting:\", cam2Attach); switchButton.disabled = false; // Enable the button // Set initial button text based on which camera is NOT active switchButton.textContent = (babylonScene.activeCamera === cam1) ? \"Switch to Camera 2 (Universal)\" : \"Switch to Camera 1 (ArcRotate)\"; } else { console.error(\"DEBUG: Could not find one or both cameras by name after delay. Check IDs and camera types in HTML and Inspector.\"); // <-- Log failure switchButton.textContent = \"Error finding cameras\"; switchButton.disabled = true; } }, 100); // 100ms delay - adjust if needed } // Check if the scene is already ready when the script runs if (sceneEl && sceneEl.isReady) { console.log(\"DEBUG: Scene was already ready. Running setup directly.\"); babylonScene = sceneEl.babylonScene; // Get scene reference directly setupCameraSwitcher(); } else if (sceneEl) { console.log(\"DEBUG: Scene not ready yet. Adding event listener.\"); sceneEl.addEventListener('bml-scene-ready', (event) => { console.log(\"DEBUG: bml-scene-ready event fired!\"); // <-- Log event firing babylonScene = event.detail.scene; setupCameraSwitcher(); }); } else { console.error(\"DEBUG: Could not find bml-scene element!\"); switchButton.textContent = \"Scene Error\"; switchButton.disabled = true; } switchButton.addEventListener('click', () => { if (!babylonScene || !cam1 || !cam2 || !canvas) { console.error(\"Scene or cameras not ready for switching.\"); return; } const currentCam = babylonScene.activeCamera; const targetCam = (currentCam === cam1) ? cam2 : cam1; const targetAttach = (targetCam === cam1) ? cam1Attach : cam2Attach; console.log(`Switching from ${currentCam.name} to ${targetCam.name}`); // Detach controls from the current camera *if* it has the method if (currentCam && typeof currentCam.detachControl === 'function') { console.log(`Detaching controls from ${currentCam.name}`); currentCam.detachControl(canvas); } // Set the new active camera babylonScene.activeCamera = targetCam; // Attach controls to the new camera *if* it has the method if (targetCam && typeof targetCam.attachControl === 'function') { console.log(`Attaching controls to ${targetCam.name}`); targetCam.attachControl(canvas, true); // Always attach to the new active camera } else { console.log(`Controls not attached to ${targetCam.name} (method missing)`); } // Update button text switchButton.textContent = (targetCam === cam1) ? \"Switch to Camera 2 (Universal)\" : \"Switch to Camera 1 (ArcRotate)\"; }); // Disable button initially until cameras are confirmed switchButton.disabled = true; </script> ``` Mesh Loading (GLB) Shows how to load an external .glb model using the geometry component. ```html <!DOCTYPE html> BabylonML - Mesh Example html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; } bml-scene { width: 100%; height: 100%; display: block; } <!-- Load the GLB mesh --> <!-- Using a model from Firebase Storage --> <bml-entity geometry=\"type: mesh; src: https://firebasestorage.googleapis.com/v0/b/story-splat.firebasestorage.app/o/users%2FmFNJrfet99Qv9mMX2OC6hewy1xC2%2Fsplats%2FGreek_Statue_London_textured_mesh_lowpoly_glb.glb?alt=media&token=d79e2c56-420b-4e1f-81d8-0a7f3cdcf43c\" position=\"0 0 0\" rotation=\"0 0 0\" scale=\"1 1 1\"> </bml-entity> </bml-scene> ``` Photo Dome Demonstrates creating a 360-degree photo environment using the geometry component. ```html <!DOCTYPE html> BabylonML - Photo Dome Example html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; } bml-scene { width: 100%; height: 100%; display: block; } <!-- Load BabylonML library --> <script src=\"https://tinyurl.com/babylonml\"></script> <!-- Photo Dome --> <!-- Using a publicly available 360 image from BabylonJS examples --> <bml-entity geometry=\"type: photodome; src: https://playground.babylonjs.com/textures/360photo.jpg; size: 1000\"> <!-- The size should be large enough to encompass the camera --> </bml-entity> <!-- Optional: Add a small object inside the dome to verify perspective --> <bml-entity geometry=\"type: box; size: 0.5\" position=\"0 -1 2\" material=\"color: red\"></bml-entity> </bml-scene> ``` Video Dome Demonstrates creating a 360-degree video environment using the geometry component, including custom zoom interaction. ```html <!DOCTYPE html> BabylonML - Video Dome Example html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; } bml-scene { width: 100%; height: 100%; display: block; } <!-- Load BabylonML library --> <script src=\"https://tinyurl.com/babylonml\"></script> <!-- Video Dome --> <!-- Using a publicly available 360 video --> <!-- Note: Autoplay might be blocked by browser policy if not muted or interacted with --> <bml-entity id=\"video-dome-entity\" geometry=\"type: videodome; src: https://assets.babylonjs.com/photoDomes/solarProbeMission.mp4; size: 1000; autoPlay: true; loop: true; muted: true; clickToPlay: true\"> <!-- clickToPlay: true allows user interaction to start/pause --> </bml-entity> <!-- Optional: Add a small object inside the dome --> <bml-entity geometry=\"type: sphere; diameter: 0.5\" position=\"0 0 0\" material=\"color: blue\"></bml-entity> </bml-scene> <script> const sceneEl = document.querySelector('bml-scene'); let babylonScene = null; let canvas = null; let camera = null; // We only need the VideoDome instance, not necessarily its mesh for fovMultiplier let videoDomeInstance = null; // Function to initialize the custom zoom logic function initializeVideoDomeZoom() { console.log(\"DEBUG: initializeVideoDomeZoom called.\"); if (!sceneEl.isReady || !babylonScene) { console.log(\"DEBUG: Scene not ready yet in initializeVideoDomeZoom.\"); return; } canvas = sceneEl.babylonCanvas; camera = babylonScene.activeCamera; // Get active camera const videoDomeEntity = document.getElementById('video-dome-entity'); if (!videoDomeEntity) { console.error(\"DEBUG: Could not find video dome entity element by ID 'video-dome-entity'.\"); return; } // --- Custom Zoom Logic Variables --- var zoomLevel = 1; // Function to set up the zoom logic *after* the VideoDome instance is confirmed const setupZoomLogic = (domeInstance) => { console.log(\"DEBUG: setupZoomLogic called with dome instance:\", domeInstance); if (!camera || !canvas || !domeInstance) { console.error(`DEBUG: Cannot setup zoom logic. Missing camera, canvas, or domeInstance.`); return; } // --- Detach Camera Controls --- if (camera.inputs && camera.inputs.attached.mousewheel) { console.log(\"DEBUG: Detaching default mousewheel control.\"); camera.inputs.attached.mousewheel.detachControl(canvas); } else { console.warn(\"Could not detach mousewheel control.\"); } // --- Register Render Loop Logic --- // This function will run every frame AFTER setupZoomLogic is called babylonScene.registerAfterRender(function() { // Ensure domeInstance is still valid and has the property if (!domeInstance || domeInstance.fovMultiplier === undefined) { // It might take a frame or two for fovMultiplier to be ready after instance creation // console.warn(\"Waiting for domeInstance or fovMultiplier...\"); return; } domeInstance.fovMultiplier = zoomLevel; domeInstance.material.alpha = 1 - (zoomLevel - 1) * 0.9; // Adjust alpha based on zoom level }); // --- Register Pointer Observable Logic --- // This function will run on mouse wheel events AFTER setupZoomLogic is called babylonScene.onPointerObservable.add(function(e) { if (!domeInstance) { return; } // Ensure instance exists const wheelDelta = e.event.wheelDelta || -e.event.deltaY; if (wheelDelta === 0) return; zoomLevel += wheelDelta * -0.0005; if (zoomLevel < 0.1) { zoomLevel = 0.1; } if (zoomLevel > 2) { zoomLevel = 2; } }, 8); console.log(\"Custom video dome zoom script event listeners registered successfully.\"); }; // End of setupZoomLogic function // --- Wait for Geometry Readiness --- // Check if the geometry object is already available when initializeVideoDomeZoom runs if (videoDomeEntity.BabylonGeometryObject) { console.log(\"DEBUG: Video dome geometry object was already available.\"); // Assign the instance and call setup immediately videoDomeInstance = videoDomeEntity.BabylonGeometryObject; setupZoomLogic(videoDomeInstance); } else { // If not ready, wait for the component to dispatch the event console.log(\"DEBUG: Waiting for 'bml-geometry-ready' event on video dome entity...\"); videoDomeEntity.addEventListener('bml-geometry-ready', (event) => { console.log(\"DEBUG: 'bml-geometry-ready' event received for video dome.\"); // Assign the instance from the event and call setup videoDomeInstance = event.detail.geometryObject; setupZoomLogic(videoDomeInstance); }, { once: true }); // Listen only once } } // End of initializeVideoDomeZoom function // Check if the scene is already ready when the script runs if (sceneEl && sceneEl.isReady) { console.log(\"DEBUG: Scene was already ready. Running setup directly.\"); babylonScene = sceneEl.babylonScene; // Get scene reference directly initializeVideoDomeZoom(); } else if (sceneEl) { console.log(\"DEBUG: Scene not ready yet. Adding event listener for bml-scene-ready.\"); sceneEl.addEventListener('bml-scene-ready', (event) => { console.log(\"DEBUG: bml-scene-ready event fired!\"); babylonScene = event.detail.scene; // Get scene from event detail initializeVideoDomeZoom(); }); } else { console.error(\"DEBUG: Could not find bml-scene element!\"); } </script> ``` VR Scene Shows how to enable a basic VR experience using the xr=\"vr\" attribute on <bml-scene> . ```html <!DOCTYPE html> BabylonML - VR Example","title":"Live Examples"},{"location":"examples/#live-examples","text":"This page provides links to live, hosted examples demonstrating various features of BabylonML. These examples are hosted separately and load the latest version of the BabylonML library. Basic Scene Demonstrates a simple scene with a box, ground, and default camera/light. Includes dynamic material update via JavaScript. ```html <!DOCTYPE html> BabylonML - Local Test /<em> Basic styling to make the scene visible </em>/ html, body { margin: 0; padding: 0; overflow: hidden; /<em> Prevent scrollbars </em>/ height: 100%; width: 100%; } bml-scene { width: 100vw; /<em> Viewport width </em>/ height: 100vh; /<em> Viewport height </em>/ display: block; /<em> Make it a block element </em>/ } canvas { display: block; /<em> Prevent potential small gap below canvas </em>/ } <!-- A ground plane --> <bml-entity geometry=\"type: ground; width: 10; height: 10\" material=\"color: #8FBC8F\"> <!-- Position defaults to 0 0 0 --> </bml-entity> // Optional: You can add JavaScript here to interact with the scene // after it's potentially ready. const sceneEl = document.querySelector('bml-scene');</p> <pre><code> // Check if the scene is already ready when the script runs if (sceneEl &amp;&amp; sceneEl.isReady) { console.log(\"DEBUG: Scene was already ready. Running setup directly.\"); babylonScene = sceneEl.babylonScene; // Get scene reference directly console.log(\"DEBUG: babylonScene reference obtained. \", babylonScene); // lets change the color of the box to blue const box = document.getElementById('my-box'); if (box) { console.log('Attempting to change box color via attribute...'); box.setAttribute('material', 'color: #0000FF'); // Change color to blue } } else if (sceneEl) { console.log(\"DEBUG: Scene not ready yet. Adding event listener.\"); sceneEl.addEventListener('bml-scene-ready', (event) =&gt; { console.log(\"DEBUG: bml-scene-ready event fired!\"); // &lt;-- Log event firing babylonScene = event.detail.scene; consoler.log(\"DEBUG: babylonScene reference obtained. \", babylonScene); // Example: Simple interaction after a delay setTimeout(() =&gt; { const box = document.getElementById('my-box'); if (box) { console.log('Attempting to change box color via attribute...'); box.setAttribute('material', 'color: #0000FF'); // Change color to blue } }, 5000); // After 5 seconds }); } // Example: Accessing BML global API (if implemented) if (window.BML) { console.log('BML Global API found:', BML); // Example: How a user might register their own component // BML.registerComponent('my-custom-spin', { ... }); } </code></pre> ``` Explicit Camera & Light Placeholder Shows how defining an explicit camera overrides the default, and how the (currently non-functional) light attribute placeholder prevents the default light. ```html <!DOCTYPE html> BabylonML Example: Explicit Camera & Light Placeholder html, body { margin: 0; padding: 0; overflow: hidden; /<em> Prevent scrollbars </em>/ height: 100%; width: 100%; } bml-scene { width: 100vw; /<em> Viewport width </em>/ height: 100vh; /<em> Viewport height </em>/ display: block; /<em> Ensure it behaves like a block element </em>/ } canvas { display: block; } <!-- Placeholder for a light source --> <!-- IMPORTANT: This disables the default light, but doesn't create a PointLight yet! --> <bml-entity id=\"myLightSource\" light=\"type: point; intensity: 0.8; position: 0 5 0\"> <!-- This entity currently does nothing visually --> </bml-entity> <!-- A simple box entity --> <bml-entity geometry=\"type: box; size: 1\" material=\"color: #FF6347\" <!-- Tomato color --> position=\"0 1 0\"> </bml-entity> <!-- A ground plane --> <bml-entity geometry=\"type: ground; width: 10; height: 10\" material=\"color: #B0C4DE\"> <!-- LightSteelBlue color --> </bml-entity> </bml-scene> <script> // Optional: Add a light programmatically since the component doesn't exist yet document.querySelector('bml-scene').addEventListener('bml-scene-ready', (event) => { const babylonScene = event.detail.scene; // Uncomment the lines below to add a light via JavaScript // console.log(\"Adding programmatic light...\"); // const pointLight = new BABYLON.PointLight(\"programmaticLight\", new BABYLON.Vector3(0, 5, 0), babylonScene); // pointLight.intensity = 0.8; // console.log(\"Programmatic light added.\"); }); </script> ``` Multiple Cameras Illustrates defining multiple cameras and switching between them using JavaScript. ```html <!DOCTYPE html> BabylonML Example: Multiple Cameras html, body { margin: 0; padding: 0; overflow: hidden; /<em> Prevent scrollbars </em>/ height: 100%; width: 100%; } bml-scene { width: 100vw; /<em> Viewport width </em>/ height: 100vh; /<em> Viewport height </em>/ display: block; /<em> Ensure it behaves like a block element </em>/ } canvas { display: block; } /<em> Style for the button </em>/ #switchCameraButton { position: absolute; top: 10px; left: 10px; padding: 10px 15px; font-size: 16px; cursor: pointer; z-index: 10; /<em> Ensure it's above the canvas </em>/ } Switch to Camera 2 <!-- This scene demonstrates defining multiple cameras. - The first camera entity encountered (\"camera1\", ArcRotate) will become the active camera by default. - The second camera (\"camera2\", Universal) will be created but inactive initially. - Click the button in the top-left corner to switch between them. - Since at least one camera is defined, the default FreeCamera is NOT created. - Since no light attribute is defined, the default HemisphericLight IS created. --> <bml-scene> <!-- First Camera (ArcRotate, active initially) --> <bml-entity id=\"camera1\" camera=\"type: arcRotate; alpha: -1.57; beta: 1.4; radius: 8; target: 0 1 0; attachControl: true\"> <!-- attachControl: true --> </bml-entity> <!-- Second Camera (Universal, inactive initially) --> <bml-entity id=\"camera2\" camera=\"type: universal; position: 5 2 5; target: 0 1 0; attachControl: false\"> <!-- attachControl: false --> </bml-entity> <!-- A simple box entity --> <bml-entity geometry=\"type: box; size: 1\" material=\"color: #6A5ACD\" <!-- SlateBlue color --> position=\"0 1 0\"> </bml-entity> <!-- A ground plane --> <bml-entity geometry=\"type: ground; width: 10; height: 10\" material=\"color: #98FB98\"> <!-- PaleGreen color --> </bml-entity> </bml-scene> <script> const sceneEl = document.querySelector('bml-scene'); const switchButton = document.getElementById('switchCameraButton'); let babylonScene = null; let canvas = null; let cam1 = null; // ArcRotate let cam2 = null; // Universal let cam1Attach = true; // Default based on attribute let cam2Attach = false; // Default based on attribute // Function to set up cameras and button once scene is ready function setupCameraSwitcher() { console.log(\"DEBUG: setupCameraSwitcher called.\"); if (!sceneEl.isReady || !babylonScene) { console.log(\"DEBUG: Scene not ready yet in setupCameraSwitcher.\"); return; // Should not happen if called correctly, but good check } canvas = sceneEl.babylonCanvas; // Get canvas reference from scene element // Add a small delay to ensure camera components have initialized AFTER scene is ready setTimeout(() => { console.log(\"DEBUG: setTimeout callback running...\"); // <-- Log timeout callback console.log(\"DEBUG: Available cameras:\", babylonScene.cameras.map(c => c.name)); // <-- Log available camera names // Get camera instances using their auto-generated names (check inspector if needed) cam1 = babylonScene.getCameraByName('camera1_arcRotateCamera'); cam2 = babylonScene.getCameraByName('camera2_universalCamera'); // Get camera entities to check original attachControl attribute const camEntity1 = document.getElementById('camera1'); const camEntity2 = document.getElementById('camera2'); // Store original attachControl settings (simple check) cam1Attach = (camEntity1?.getAttribute('camera') || '').includes('attachControl: true'); cam2Attach = (camEntity2?.getAttribute('camera') || '').includes('attachControl: true'); // Note: cam2 is false in HTML if (cam1 && cam2) { console.log(\"DEBUG: Cameras found by name:\", cam1.name, cam2.name); // <-- Log success console.log(\"Initial active camera:\", babylonScene.activeCamera.name); console.log(\"Camera 1 attachControl setting:\", cam1Attach); console.log(\"Camera 2 attachControl setting:\", cam2Attach); switchButton.disabled = false; // Enable the button // Set initial button text based on which camera is NOT active switchButton.textContent = (babylonScene.activeCamera === cam1) ? \"Switch to Camera 2 (Universal)\" : \"Switch to Camera 1 (ArcRotate)\"; } else { console.error(\"DEBUG: Could not find one or both cameras by name after delay. Check IDs and camera types in HTML and Inspector.\"); // <-- Log failure switchButton.textContent = \"Error finding cameras\"; switchButton.disabled = true; } }, 100); // 100ms delay - adjust if needed } // Check if the scene is already ready when the script runs if (sceneEl && sceneEl.isReady) { console.log(\"DEBUG: Scene was already ready. Running setup directly.\"); babylonScene = sceneEl.babylonScene; // Get scene reference directly setupCameraSwitcher(); } else if (sceneEl) { console.log(\"DEBUG: Scene not ready yet. Adding event listener.\"); sceneEl.addEventListener('bml-scene-ready', (event) => { console.log(\"DEBUG: bml-scene-ready event fired!\"); // <-- Log event firing babylonScene = event.detail.scene; setupCameraSwitcher(); }); } else { console.error(\"DEBUG: Could not find bml-scene element!\"); switchButton.textContent = \"Scene Error\"; switchButton.disabled = true; } switchButton.addEventListener('click', () => { if (!babylonScene || !cam1 || !cam2 || !canvas) { console.error(\"Scene or cameras not ready for switching.\"); return; } const currentCam = babylonScene.activeCamera; const targetCam = (currentCam === cam1) ? cam2 : cam1; const targetAttach = (targetCam === cam1) ? cam1Attach : cam2Attach; console.log(`Switching from ${currentCam.name} to ${targetCam.name}`); // Detach controls from the current camera *if* it has the method if (currentCam && typeof currentCam.detachControl === 'function') { console.log(`Detaching controls from ${currentCam.name}`); currentCam.detachControl(canvas); } // Set the new active camera babylonScene.activeCamera = targetCam; // Attach controls to the new camera *if* it has the method if (targetCam && typeof targetCam.attachControl === 'function') { console.log(`Attaching controls to ${targetCam.name}`); targetCam.attachControl(canvas, true); // Always attach to the new active camera } else { console.log(`Controls not attached to ${targetCam.name} (method missing)`); } // Update button text switchButton.textContent = (targetCam === cam1) ? \"Switch to Camera 2 (Universal)\" : \"Switch to Camera 1 (ArcRotate)\"; }); // Disable button initially until cameras are confirmed switchButton.disabled = true; </script> ``` Mesh Loading (GLB) Shows how to load an external .glb model using the geometry component. ```html <!DOCTYPE html> BabylonML - Mesh Example html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; } bml-scene { width: 100%; height: 100%; display: block; } <!-- Load the GLB mesh --> <!-- Using a model from Firebase Storage --> <bml-entity geometry=\"type: mesh; src: https://firebasestorage.googleapis.com/v0/b/story-splat.firebasestorage.app/o/users%2FmFNJrfet99Qv9mMX2OC6hewy1xC2%2Fsplats%2FGreek_Statue_London_textured_mesh_lowpoly_glb.glb?alt=media&token=d79e2c56-420b-4e1f-81d8-0a7f3cdcf43c\" position=\"0 0 0\" rotation=\"0 0 0\" scale=\"1 1 1\"> </bml-entity> </bml-scene> ``` Photo Dome Demonstrates creating a 360-degree photo environment using the geometry component. ```html <!DOCTYPE html> BabylonML - Photo Dome Example html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; } bml-scene { width: 100%; height: 100%; display: block; } <!-- Load BabylonML library --> <script src=\"https://tinyurl.com/babylonml\"></script> <!-- Photo Dome --> <!-- Using a publicly available 360 image from BabylonJS examples --> <bml-entity geometry=\"type: photodome; src: https://playground.babylonjs.com/textures/360photo.jpg; size: 1000\"> <!-- The size should be large enough to encompass the camera --> </bml-entity> <!-- Optional: Add a small object inside the dome to verify perspective --> <bml-entity geometry=\"type: box; size: 0.5\" position=\"0 -1 2\" material=\"color: red\"></bml-entity> </bml-scene> ``` Video Dome Demonstrates creating a 360-degree video environment using the geometry component, including custom zoom interaction. ```html <!DOCTYPE html> BabylonML - Video Dome Example html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; } bml-scene { width: 100%; height: 100%; display: block; } <!-- Load BabylonML library --> <script src=\"https://tinyurl.com/babylonml\"></script> <!-- Video Dome --> <!-- Using a publicly available 360 video --> <!-- Note: Autoplay might be blocked by browser policy if not muted or interacted with --> <bml-entity id=\"video-dome-entity\" geometry=\"type: videodome; src: https://assets.babylonjs.com/photoDomes/solarProbeMission.mp4; size: 1000; autoPlay: true; loop: true; muted: true; clickToPlay: true\"> <!-- clickToPlay: true allows user interaction to start/pause --> </bml-entity> <!-- Optional: Add a small object inside the dome --> <bml-entity geometry=\"type: sphere; diameter: 0.5\" position=\"0 0 0\" material=\"color: blue\"></bml-entity> </bml-scene> <script> const sceneEl = document.querySelector('bml-scene'); let babylonScene = null; let canvas = null; let camera = null; // We only need the VideoDome instance, not necessarily its mesh for fovMultiplier let videoDomeInstance = null; // Function to initialize the custom zoom logic function initializeVideoDomeZoom() { console.log(\"DEBUG: initializeVideoDomeZoom called.\"); if (!sceneEl.isReady || !babylonScene) { console.log(\"DEBUG: Scene not ready yet in initializeVideoDomeZoom.\"); return; } canvas = sceneEl.babylonCanvas; camera = babylonScene.activeCamera; // Get active camera const videoDomeEntity = document.getElementById('video-dome-entity'); if (!videoDomeEntity) { console.error(\"DEBUG: Could not find video dome entity element by ID 'video-dome-entity'.\"); return; } // --- Custom Zoom Logic Variables --- var zoomLevel = 1; // Function to set up the zoom logic *after* the VideoDome instance is confirmed const setupZoomLogic = (domeInstance) => { console.log(\"DEBUG: setupZoomLogic called with dome instance:\", domeInstance); if (!camera || !canvas || !domeInstance) { console.error(`DEBUG: Cannot setup zoom logic. Missing camera, canvas, or domeInstance.`); return; } // --- Detach Camera Controls --- if (camera.inputs && camera.inputs.attached.mousewheel) { console.log(\"DEBUG: Detaching default mousewheel control.\"); camera.inputs.attached.mousewheel.detachControl(canvas); } else { console.warn(\"Could not detach mousewheel control.\"); } // --- Register Render Loop Logic --- // This function will run every frame AFTER setupZoomLogic is called babylonScene.registerAfterRender(function() { // Ensure domeInstance is still valid and has the property if (!domeInstance || domeInstance.fovMultiplier === undefined) { // It might take a frame or two for fovMultiplier to be ready after instance creation // console.warn(\"Waiting for domeInstance or fovMultiplier...\"); return; } domeInstance.fovMultiplier = zoomLevel; domeInstance.material.alpha = 1 - (zoomLevel - 1) * 0.9; // Adjust alpha based on zoom level }); // --- Register Pointer Observable Logic --- // This function will run on mouse wheel events AFTER setupZoomLogic is called babylonScene.onPointerObservable.add(function(e) { if (!domeInstance) { return; } // Ensure instance exists const wheelDelta = e.event.wheelDelta || -e.event.deltaY; if (wheelDelta === 0) return; zoomLevel += wheelDelta * -0.0005; if (zoomLevel < 0.1) { zoomLevel = 0.1; } if (zoomLevel > 2) { zoomLevel = 2; } }, 8); console.log(\"Custom video dome zoom script event listeners registered successfully.\"); }; // End of setupZoomLogic function // --- Wait for Geometry Readiness --- // Check if the geometry object is already available when initializeVideoDomeZoom runs if (videoDomeEntity.BabylonGeometryObject) { console.log(\"DEBUG: Video dome geometry object was already available.\"); // Assign the instance and call setup immediately videoDomeInstance = videoDomeEntity.BabylonGeometryObject; setupZoomLogic(videoDomeInstance); } else { // If not ready, wait for the component to dispatch the event console.log(\"DEBUG: Waiting for 'bml-geometry-ready' event on video dome entity...\"); videoDomeEntity.addEventListener('bml-geometry-ready', (event) => { console.log(\"DEBUG: 'bml-geometry-ready' event received for video dome.\"); // Assign the instance from the event and call setup videoDomeInstance = event.detail.geometryObject; setupZoomLogic(videoDomeInstance); }, { once: true }); // Listen only once } } // End of initializeVideoDomeZoom function // Check if the scene is already ready when the script runs if (sceneEl && sceneEl.isReady) { console.log(\"DEBUG: Scene was already ready. Running setup directly.\"); babylonScene = sceneEl.babylonScene; // Get scene reference directly initializeVideoDomeZoom(); } else if (sceneEl) { console.log(\"DEBUG: Scene not ready yet. Adding event listener for bml-scene-ready.\"); sceneEl.addEventListener('bml-scene-ready', (event) => { console.log(\"DEBUG: bml-scene-ready event fired!\"); babylonScene = event.detail.scene; // Get scene from event detail initializeVideoDomeZoom(); }); } else { console.error(\"DEBUG: Could not find bml-scene element!\"); } </script> ``` VR Scene Shows how to enable a basic VR experience using the xr=\"vr\" attribute on <bml-scene> . ```html <!DOCTYPE html> BabylonML - VR Example","title":"Live Examples"},{"location":"getting-started/","text":"Getting Started with BabylonML This guide will walk you through setting up BabylonML and creating your first basic scene. Installation Currently, BabylonML is intended to be used directly from its source or build output within a project. Clone or Download: Obtain the BabylonML project files. Build the Framework: Navigate to the project's root directory in your terminal and run the build command: bash npm install npm run build This generates the necessary dist/babylonml.js file. Include in HTML: In your HTML file, include the built script: html <script src=\"path/to/dist/babylonml.js\"></script> Make sure the src path correctly points to the location of babylonml.js relative to your HTML file. Your First Scene Create an HTML file (e.g., index.html ) and add the following structure: <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>My First BabylonML Scene</title> <style> /* Basic styling to ensure the scene is visible */ html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; width: 100%; } bml-scene { width: 100vw; height: 100vh; display: block; } canvas { display: block; } </style> <!-- Link to the built BabylonML script --> <script src=\"../dist/babylonml.js\"></script> <!-- Adjust path as needed --> </head> <body> <bml-scene> <!-- A simple red box --> <bml-entity id=\"red-box\" position=\"0 1 -5\" geometry=\"type: box; width: 1; height: 1; depth: 1\" material=\"type: standard; diffuseColor: #FF0000\"> </bml-entity> <!-- A ground plane --> <bml-entity id=\"ground\" position=\"0 0 -5\" geometry=\"type: ground; width: 6; height: 6\" material=\"type: standard; diffuseColor: #444444\"> </bml-entity> </bml-scene> </body> </html> Running Locally Because browsers have security restrictions, you need to serve this HTML file from a local web server. Navigate: Open your terminal in the directory containing your HTML file (or the root of the BabylonML project if your HTML file is inside it, like in the examples folder). Serve: Use a simple web server. npx http-server is a good option: ```bash # If your HTML is index.html in the current directory npx http-server -c-1 If serving from the babylonml root and opening examples/basic_scene.html npx http-server . -o examples/basic_scene.html -c-1 `` The -c-1 flag disables caching, which is helpful during development. 3. **View:** Open the URL provided by the server (usually http://127.0.0.1:8080`) in your web browser. You should see a red box sitting on a grey ground plane. You've now set up and run your first BabylonML scene! Explore the other documentation sections to learn more about entities, components, and advanced features.","title":"Getting Started"},{"location":"getting-started/#getting-started-with-babylonml","text":"This guide will walk you through setting up BabylonML and creating your first basic scene.","title":"Getting Started with BabylonML"},{"location":"getting-started/#installation","text":"Currently, BabylonML is intended to be used directly from its source or build output within a project. Clone or Download: Obtain the BabylonML project files. Build the Framework: Navigate to the project's root directory in your terminal and run the build command: bash npm install npm run build This generates the necessary dist/babylonml.js file. Include in HTML: In your HTML file, include the built script: html <script src=\"path/to/dist/babylonml.js\"></script> Make sure the src path correctly points to the location of babylonml.js relative to your HTML file.","title":"Installation"},{"location":"getting-started/#your-first-scene","text":"Create an HTML file (e.g., index.html ) and add the following structure: <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>My First BabylonML Scene</title> <style> /* Basic styling to ensure the scene is visible */ html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; width: 100%; } bml-scene { width: 100vw; height: 100vh; display: block; } canvas { display: block; } </style> <!-- Link to the built BabylonML script --> <script src=\"../dist/babylonml.js\"></script> <!-- Adjust path as needed --> </head> <body> <bml-scene> <!-- A simple red box --> <bml-entity id=\"red-box\" position=\"0 1 -5\" geometry=\"type: box; width: 1; height: 1; depth: 1\" material=\"type: standard; diffuseColor: #FF0000\"> </bml-entity> <!-- A ground plane --> <bml-entity id=\"ground\" position=\"0 0 -5\" geometry=\"type: ground; width: 6; height: 6\" material=\"type: standard; diffuseColor: #444444\"> </bml-entity> </bml-scene> </body> </html>","title":"Your First Scene"},{"location":"getting-started/#running-locally","text":"Because browsers have security restrictions, you need to serve this HTML file from a local web server. Navigate: Open your terminal in the directory containing your HTML file (or the root of the BabylonML project if your HTML file is inside it, like in the examples folder). Serve: Use a simple web server. npx http-server is a good option: ```bash # If your HTML is index.html in the current directory npx http-server -c-1","title":"Running Locally"},{"location":"getting-started/#if-serving-from-the-babylonml-root-and-opening-examplesbasic_scenehtml","text":"","title":"If serving from the babylonml root and opening examples/basic_scene.html"},{"location":"getting-started/#npx-http-server-o-examplesbasic_scenehtml-c-1","text":"`` The -c-1 flag disables caching, which is helpful during development. 3. **View:** Open the URL provided by the server (usually http://127.0.0.1:8080`) in your web browser. You should see a red box sitting on a grey ground plane. You've now set up and run your first BabylonML scene! Explore the other documentation sections to learn more about entities, components, and advanced features.","title":"npx http-server . -o examples/basic_scene.html -c-1"},{"location":"components/camera/","text":"Camera Component The camera component allows you to define and configure the camera used to view the BabylonML scene. It should be attached to a <bml-entity> . The first camera component initialized in the scene will automatically become the activeCamera . Usage <bml-scene> <!-- Define an ArcRotateCamera --> <bml-entity camera=\"type: arcRotate; target: 0 1 0; alpha: -1.57; beta: 1.2; radius: 5; attachControl: true\"></bml-entity> <!-- Define a UniversalCamera (FreeCamera) --> <bml-entity camera=\"type: universal; position: 0 5 -10; target: 0 0 0; attachControl: true\"></bml-entity> <!-- Other scene entities --> <bml-box position=\"0 0 0\"></bml-box> </bml-scene> Properties The camera attribute accepts a style-like string of key-value pairs, separated by semicolons. Property Description Default Value Applicable Camera Types type The type of camera to create. universal All position The initial position of the camera. 0 5 -10 universal , free target The point the camera looks at. 0 0 0 universal , arcRotate alpha The horizontal rotation angle (radians) around the target. -PI / 2 (-90\u00b0) arcRotate beta The vertical rotation angle (radians) around the target. Clamped by default. PI / 2 (90\u00b0) arcRotate radius The distance from the camera to the target. 10 arcRotate attachControl Whether to attach default camera controls to the canvas. true All fov Field of View (vertical, radians). Not yet implemented. 0.8 All minZ Near clipping plane distance. Not yet implemented. 0.1 All maxZ Far clipping plane distance. Not yet implemented. 1000 All speed Movement speed for universal/free cameras. Not yet implemented. 1.0 universal , free Supported Camera Types: universal (or free ): A first-person style camera. Uses position and target . arcRotate : A camera that rotates around a target point based on alpha , beta , and radius . Multiple Cameras You can define multiple entities with the camera component within a single <bml-scene> . Each component will create its corresponding Babylon.js camera instance. However, Babylon.js can only render through one active camera at a time. BabylonML follows a \"first-one-wins\" approach: The first <bml-entity> with a camera component that successfully initializes will have its camera set as scene.activeCamera . Subsequent camera components will still create their cameras, but they will not be active by default. If you need to switch between cameras after the scene has loaded, you will need to use JavaScript to access the Babylon.js Scene object and set the activeCamera property manually. You can get a reference to a specific camera using scene.getCameraByName(...) or scene.getCameraByID(...) if you assign an id to your camera entities. Example (JavaScript): const sceneEl = document.querySelector('bml-scene'); sceneEl.addEventListener('bml-scene-ready', (event) => { const babylonScene = event.detail.scene; // Assuming you have <bml-entity id=\"camera2\" camera=\"...\"> const secondCamera = babylonScene.getCameraByID('camera2_universalCamera'); // Name might vary based on type/id if (secondCamera) { // Switch to the second camera after 5 seconds setTimeout(() => { babylonScene.activeCamera = secondCamera; console.log('Switched active camera to:', secondCamera.name); }, 5000); } }); Live Example: View Multiple Camera Scene Note: Currently, only the initial properties set via the attribute are used. Dynamically updating the camera attribute after the scene loads might not fully reconfigure the camera; it might dispose the old one and create a new one based on the new attribute string. Active Camera: The framework automatically sets the first camera component encountered in the DOM as the scene's active camera. If you define multiple cameras, only the first one will be active initially.","title":"Camera"},{"location":"components/camera/#camera-component","text":"The camera component allows you to define and configure the camera used to view the BabylonML scene. It should be attached to a <bml-entity> . The first camera component initialized in the scene will automatically become the activeCamera .","title":"Camera Component"},{"location":"components/camera/#usage","text":"<bml-scene> <!-- Define an ArcRotateCamera --> <bml-entity camera=\"type: arcRotate; target: 0 1 0; alpha: -1.57; beta: 1.2; radius: 5; attachControl: true\"></bml-entity> <!-- Define a UniversalCamera (FreeCamera) --> <bml-entity camera=\"type: universal; position: 0 5 -10; target: 0 0 0; attachControl: true\"></bml-entity> <!-- Other scene entities --> <bml-box position=\"0 0 0\"></bml-box> </bml-scene>","title":"Usage"},{"location":"components/camera/#properties","text":"The camera attribute accepts a style-like string of key-value pairs, separated by semicolons. Property Description Default Value Applicable Camera Types type The type of camera to create. universal All position The initial position of the camera. 0 5 -10 universal , free target The point the camera looks at. 0 0 0 universal , arcRotate alpha The horizontal rotation angle (radians) around the target. -PI / 2 (-90\u00b0) arcRotate beta The vertical rotation angle (radians) around the target. Clamped by default. PI / 2 (90\u00b0) arcRotate radius The distance from the camera to the target. 10 arcRotate attachControl Whether to attach default camera controls to the canvas. true All fov Field of View (vertical, radians). Not yet implemented. 0.8 All minZ Near clipping plane distance. Not yet implemented. 0.1 All maxZ Far clipping plane distance. Not yet implemented. 1000 All speed Movement speed for universal/free cameras. Not yet implemented. 1.0 universal , free Supported Camera Types: universal (or free ): A first-person style camera. Uses position and target . arcRotate : A camera that rotates around a target point based on alpha , beta , and radius .","title":"Properties"},{"location":"components/camera/#multiple-cameras","text":"You can define multiple entities with the camera component within a single <bml-scene> . Each component will create its corresponding Babylon.js camera instance. However, Babylon.js can only render through one active camera at a time. BabylonML follows a \"first-one-wins\" approach: The first <bml-entity> with a camera component that successfully initializes will have its camera set as scene.activeCamera . Subsequent camera components will still create their cameras, but they will not be active by default. If you need to switch between cameras after the scene has loaded, you will need to use JavaScript to access the Babylon.js Scene object and set the activeCamera property manually. You can get a reference to a specific camera using scene.getCameraByName(...) or scene.getCameraByID(...) if you assign an id to your camera entities. Example (JavaScript): const sceneEl = document.querySelector('bml-scene'); sceneEl.addEventListener('bml-scene-ready', (event) => { const babylonScene = event.detail.scene; // Assuming you have <bml-entity id=\"camera2\" camera=\"...\"> const secondCamera = babylonScene.getCameraByID('camera2_universalCamera'); // Name might vary based on type/id if (secondCamera) { // Switch to the second camera after 5 seconds setTimeout(() => { babylonScene.activeCamera = secondCamera; console.log('Switched active camera to:', secondCamera.name); }, 5000); } }); Live Example: View Multiple Camera Scene Note: Currently, only the initial properties set via the attribute are used. Dynamically updating the camera attribute after the scene loads might not fully reconfigure the camera; it might dispose the old one and create a new one based on the new attribute string. Active Camera: The framework automatically sets the first camera component encountered in the DOM as the scene's active camera. If you define multiple cameras, only the first one will be active initially.","title":"Multiple Cameras"},{"location":"components/geometry/","text":"Component Reference: geometry The geometry component defines the shape or mesh of an entity. It can create various primitive shapes using Babylon.js's MeshBuilder , load external 3D models using SceneLoader , or create immersive PhotoDome and VideoDome objects. Attribute Syntax The geometry attribute uses the component/map string format. The type property is required to specify the shape. Other properties depend on the chosen type. <!-- A box with specific dimensions --> <bml-entity geometry=\"type: box; width: 2; height: 1; depth: 0.5\"></bml-entity> <!-- A sphere with a specific diameter --> <bml-entity geometry=\"type: sphere; diameter: 1.5\"></bml-entity> <!-- A ground plane --> <bml-entity geometry=\"type: ground; width: 10; height: 10\"></bml-entity> <!-- Load an external mesh --> <bml-entity geometry=\"type: mesh; src: /path/to/model.glb\"></bml-entity> <!-- Display a 360 photo --> <bml-entity geometry=\"type: photodome; src: /path/to/photo.jpg; size: 1000\"></bml-entity> <!-- Display a 360 video --> <bml-entity geometry=\"type: videodome; src: /path/to/video.mp4; size: 1000\"></bml-entity> Common Properties Property Type Default Description type string 'box' The type of primitive shape to create. Required. Geometry Types and Specific Properties The geometry component creates or loads a Babylon.js Mesh (or a helper object like PhotoDome which contains a mesh) and parents it to the entity's TransformNode . type: box Creates a rectangular prism. Property Type Default Description width number 1 Size along the X-axis. height number 1 Size along the Y-axis. depth number 1 Size along the Z-axis. size number n/a If set, overrides width , height , and depth . Example: <bml-entity geometry=\"type: box; size: 2\"></bml-entity> type: sphere Creates a sphere. Property Type Default Description diameter number 1 Default diameter for all axes. diameterX number n/a Diameter along the X-axis (overrides diameter ). diameterY number n/a Diameter along the Y-axis (overrides diameter ). diameterZ number n/a Diameter along the Z-axis (overrides diameter ). segments number 32 Number of vertical segments (level of detail). Example: <bml-entity geometry=\"type: sphere; diameter: 3; segments: 16\"></bml-entity> type: plane Creates a flat plane (oriented horizontally by default). Property Type Default Description width number 1 Size along the X-axis. height number 1 Size along the Z-axis (depth). size number n/a If set, overrides width and height . Example: <bml-entity geometry=\"type: plane; width: 5; height: 2\"></bml-entity> type: ground Creates a flat, tessellated plane optimized for use as ground. Property Type Default Description width number 10 Size along the X-axis. height number 10 Size along the Z-axis (depth). subdivisions number 1 Number of subdivisions per side. Example: <bml-entity geometry=\"type: ground; width: 20; height: 20; subdivisions: 4\"></bml-entity> type: cylinder / type: cone Creates a cylinder or cone (a cone is a cylinder with diameterTop: 0 ). Property Type Default (Cyl/Cone) Description height number 1 Height along the Y-axis. diameterTop number 1 / 0 Diameter at the top Y end. diameterBottom number 1 Diameter at the bottom Y end. diameter number n/a If set, overrides diameterTop / Bottom (Cone top remains 0). tessellation number 24 Number of radial sides (level of detail). Example (Cylinder): <bml-entity geometry=\"type: cylinder; height: 3; diameter: 0.5; tessellation: 32\"></bml-entity> Example (Cone): <bml-entity geometry=\"type: cone; height: 2; diameterBottom: 1.5\"></bml-entity> type: mesh Loads an external 3D model file (e.g., .glb , .gltf , .obj ). Uses SceneLoader.ImportMeshAsync . The first mesh found in the loaded file (or the one named __root__ ) will be used and parented to the entity. Property Type Default Description src string n/a Required. URL or path to the 3D model file. Example: <!-- Load a GLB model --> <bml-entity geometry=\"type: mesh; src: assets/models/my_robot.glb\" position=\"0 1 0\"></bml-entity> <!-- Load from a URL --> <bml-entity geometry=\"type: mesh; src: https://example.com/models/spaceship.gltf\"></bml-entity> Live Example: View Mesh Loading Example Note: Mesh loading is asynchronous. The mesh will appear once loading is complete. Check the browser console for loading progress and errors. type: photodome Creates a large sphere with an equirectangular photographic texture mapped to the inside, used for displaying 360\u00b0 photos. Uses BABYLON.PhotoDome . Property Type Default Description src string n/a Required. URL or path to the 360\u00b0 image file (e.g., .jpg , .png ). resolution number 32 The segmentation of the sphere (higher means smoother). size number 1000 The diameter of the sphere. Should be large enough to encompass the scene. useDirectMapping boolean false Specifies if the texture is mapped directly or needs correction (rarely needed). Example: <bml-entity geometry=\"type: photodome; src: assets/textures/skybox_360.jpg; size: 1500\"></bml-entity> Live Example: View Photo Dome Example type: videodome Creates a large sphere with an equirectangular video texture mapped to the inside, used for displaying 360\u00b0 videos. Uses BABYLON.VideoDome . Property Type Default Description src string n/a Required. URL or path to the 360\u00b0 video file (e.g., .mp4 , .webm ). resolution number 32 The segmentation of the sphere. size number 1000 The diameter of the sphere. autoPlay boolean true Whether the video should start playing automatically. Requires muted: true . loop boolean true Whether the video should loop. muted boolean true Whether the video sound is muted (often required for autoplay). clickToPlay boolean false If true , the video only plays after the user clicks/taps on the dome. poster string n/a URL of an image to show before the video loads or plays. Example: <bml-entity geometry=\"type: videodome; src: assets/videos/surfing_360.mp4; size: 1200; muted: false; clickToPlay: true\"></bml-entity> Live Example: View Video Dome Example Notes If you change the type or the src (for relevant types), the old geometry object (mesh, dome) will be disposed and a new one created or loaded. For primitive types ( box , sphere , etc.), changing size properties (like width , diameter ) after initial creation currently causes the mesh to be disposed and recreated. For mesh , photodome , and videodome , changing properties other than src after creation is not currently supported (the object would need to be recreated by changing the src or type ). The created/loaded mesh (or the mesh inside a dome) is added as a child to the entity's main TransformNode . Materials should be applied via the material component. Note that PhotoDome and VideoDome manage their own internal textures/materials, so applying an external material component might have no effect or unintended consequences on them. For loaded meshes ( type: mesh ), the material component should generally work as expected on the mesh surfaces.","title":"Geometry"},{"location":"components/geometry/#component-reference-geometry","text":"The geometry component defines the shape or mesh of an entity. It can create various primitive shapes using Babylon.js's MeshBuilder , load external 3D models using SceneLoader , or create immersive PhotoDome and VideoDome objects.","title":"Component Reference: geometry"},{"location":"components/geometry/#attribute-syntax","text":"The geometry attribute uses the component/map string format. The type property is required to specify the shape. Other properties depend on the chosen type. <!-- A box with specific dimensions --> <bml-entity geometry=\"type: box; width: 2; height: 1; depth: 0.5\"></bml-entity> <!-- A sphere with a specific diameter --> <bml-entity geometry=\"type: sphere; diameter: 1.5\"></bml-entity> <!-- A ground plane --> <bml-entity geometry=\"type: ground; width: 10; height: 10\"></bml-entity> <!-- Load an external mesh --> <bml-entity geometry=\"type: mesh; src: /path/to/model.glb\"></bml-entity> <!-- Display a 360 photo --> <bml-entity geometry=\"type: photodome; src: /path/to/photo.jpg; size: 1000\"></bml-entity> <!-- Display a 360 video --> <bml-entity geometry=\"type: videodome; src: /path/to/video.mp4; size: 1000\"></bml-entity>","title":"Attribute Syntax"},{"location":"components/geometry/#common-properties","text":"Property Type Default Description type string 'box' The type of primitive shape to create. Required.","title":"Common Properties"},{"location":"components/geometry/#geometry-types-and-specific-properties","text":"The geometry component creates or loads a Babylon.js Mesh (or a helper object like PhotoDome which contains a mesh) and parents it to the entity's TransformNode .","title":"Geometry Types and Specific Properties"},{"location":"components/geometry/#type-box","text":"Creates a rectangular prism. Property Type Default Description width number 1 Size along the X-axis. height number 1 Size along the Y-axis. depth number 1 Size along the Z-axis. size number n/a If set, overrides width , height , and depth . Example: <bml-entity geometry=\"type: box; size: 2\"></bml-entity>","title":"type: box"},{"location":"components/geometry/#type-sphere","text":"Creates a sphere. Property Type Default Description diameter number 1 Default diameter for all axes. diameterX number n/a Diameter along the X-axis (overrides diameter ). diameterY number n/a Diameter along the Y-axis (overrides diameter ). diameterZ number n/a Diameter along the Z-axis (overrides diameter ). segments number 32 Number of vertical segments (level of detail). Example: <bml-entity geometry=\"type: sphere; diameter: 3; segments: 16\"></bml-entity>","title":"type: sphere"},{"location":"components/geometry/#type-plane","text":"Creates a flat plane (oriented horizontally by default). Property Type Default Description width number 1 Size along the X-axis. height number 1 Size along the Z-axis (depth). size number n/a If set, overrides width and height . Example: <bml-entity geometry=\"type: plane; width: 5; height: 2\"></bml-entity>","title":"type: plane"},{"location":"components/geometry/#type-ground","text":"Creates a flat, tessellated plane optimized for use as ground. Property Type Default Description width number 10 Size along the X-axis. height number 10 Size along the Z-axis (depth). subdivisions number 1 Number of subdivisions per side. Example: <bml-entity geometry=\"type: ground; width: 20; height: 20; subdivisions: 4\"></bml-entity>","title":"type: ground"},{"location":"components/geometry/#type-cylinder-type-cone","text":"Creates a cylinder or cone (a cone is a cylinder with diameterTop: 0 ). Property Type Default (Cyl/Cone) Description height number 1 Height along the Y-axis. diameterTop number 1 / 0 Diameter at the top Y end. diameterBottom number 1 Diameter at the bottom Y end. diameter number n/a If set, overrides diameterTop / Bottom (Cone top remains 0). tessellation number 24 Number of radial sides (level of detail). Example (Cylinder): <bml-entity geometry=\"type: cylinder; height: 3; diameter: 0.5; tessellation: 32\"></bml-entity> Example (Cone): <bml-entity geometry=\"type: cone; height: 2; diameterBottom: 1.5\"></bml-entity>","title":"type: cylinder / type: cone"},{"location":"components/geometry/#type-mesh","text":"Loads an external 3D model file (e.g., .glb , .gltf , .obj ). Uses SceneLoader.ImportMeshAsync . The first mesh found in the loaded file (or the one named __root__ ) will be used and parented to the entity. Property Type Default Description src string n/a Required. URL or path to the 3D model file. Example: <!-- Load a GLB model --> <bml-entity geometry=\"type: mesh; src: assets/models/my_robot.glb\" position=\"0 1 0\"></bml-entity> <!-- Load from a URL --> <bml-entity geometry=\"type: mesh; src: https://example.com/models/spaceship.gltf\"></bml-entity> Live Example: View Mesh Loading Example Note: Mesh loading is asynchronous. The mesh will appear once loading is complete. Check the browser console for loading progress and errors.","title":"type: mesh"},{"location":"components/geometry/#type-photodome","text":"Creates a large sphere with an equirectangular photographic texture mapped to the inside, used for displaying 360\u00b0 photos. Uses BABYLON.PhotoDome . Property Type Default Description src string n/a Required. URL or path to the 360\u00b0 image file (e.g., .jpg , .png ). resolution number 32 The segmentation of the sphere (higher means smoother). size number 1000 The diameter of the sphere. Should be large enough to encompass the scene. useDirectMapping boolean false Specifies if the texture is mapped directly or needs correction (rarely needed). Example: <bml-entity geometry=\"type: photodome; src: assets/textures/skybox_360.jpg; size: 1500\"></bml-entity> Live Example: View Photo Dome Example","title":"type: photodome"},{"location":"components/geometry/#type-videodome","text":"Creates a large sphere with an equirectangular video texture mapped to the inside, used for displaying 360\u00b0 videos. Uses BABYLON.VideoDome . Property Type Default Description src string n/a Required. URL or path to the 360\u00b0 video file (e.g., .mp4 , .webm ). resolution number 32 The segmentation of the sphere. size number 1000 The diameter of the sphere. autoPlay boolean true Whether the video should start playing automatically. Requires muted: true . loop boolean true Whether the video should loop. muted boolean true Whether the video sound is muted (often required for autoplay). clickToPlay boolean false If true , the video only plays after the user clicks/taps on the dome. poster string n/a URL of an image to show before the video loads or plays. Example: <bml-entity geometry=\"type: videodome; src: assets/videos/surfing_360.mp4; size: 1200; muted: false; clickToPlay: true\"></bml-entity> Live Example: View Video Dome Example","title":"type: videodome"},{"location":"components/geometry/#notes","text":"If you change the type or the src (for relevant types), the old geometry object (mesh, dome) will be disposed and a new one created or loaded. For primitive types ( box , sphere , etc.), changing size properties (like width , diameter ) after initial creation currently causes the mesh to be disposed and recreated. For mesh , photodome , and videodome , changing properties other than src after creation is not currently supported (the object would need to be recreated by changing the src or type ). The created/loaded mesh (or the mesh inside a dome) is added as a child to the entity's main TransformNode . Materials should be applied via the material component. Note that PhotoDome and VideoDome manage their own internal textures/materials, so applying an external material component might have no effect or unintended consequences on them. For loaded meshes ( type: mesh ), the material component should generally work as expected on the mesh surfaces.","title":"Notes"},{"location":"components/material/","text":"Component Reference: material The material component defines the surface appearance of an entity's mesh (created by the geometry component). It primarily uses Babylon.js's StandardMaterial . Attribute Syntax The material attribute uses the component/map string format. The type property determines the kind of material (currently only standard is fully supported). Other properties control visual aspects like color and texture. <!-- A simple red material --> <bml-entity material=\"type: standard; diffuseColor: red\"></bml-entity> <!-- A material with diffuse and emissive colors --> <bml-entity material=\"type: standard; diffuseColor: #00FF00; emissiveColor: #333333\"></bml-entity> <!-- A material using a texture (requires texture loading logic) --> <!-- <bml-entity material=\"type: standard; diffuseTexture: path/to/texture.jpg\"></bml-entity> --> Common Properties Property Type Default Description type string 'standard' The type of material to create. Currently standard . type: standard Properties These properties apply when type is standard (or omitted). They correspond to properties of Babylon.js's StandardMaterial . Property Type Default Description diffuseColor color #FFFFFF (White) The base color of the material under light. emissiveColor color #000000 (Black) Color emitted by the material, independent of light (makes it glow). specularColor color #FFFFFF (White) Color of highlights from light sources. ambientColor color #000000 (Black) Color of the material in ambient light (less commonly used). alpha number 1.0 Overall transparency (0 = fully transparent, 1 = fully opaque). specularPower number 64 Controls the sharpness/size of specular highlights. Higher is sharper. wireframe boolean false If true , renders the mesh as a wireframe instead of solid surfaces. backFaceCulling boolean true If true (default), hides the back faces of polygons for performance. Set to false for double-sided materials. diffuseTexture string (URL) null URL of the texture image for the base color. (Texture loading needs implementation) emissiveTexture string (URL) null URL of the texture for emissive color. (Texture loading needs implementation) ... (other StandardMaterial properties like bumpTexture, ambientTexture etc. could be added) Color Parsing: Color properties accept standard CSS color formats like #RRGGBB , #RGB , color names ( red , blue ), rgb(r,g,b) . Underlying Babylon.js Object This component creates and manages a BABYLON.StandardMaterial instance and applies it to the mesh created by the geometry component on the same entity. Example <bml-scene> <!-- A shiny blue sphere --> <bml-entity geometry=\"type: sphere\" position=\"0 1 -5\" material=\"type: standard; diffuseColor: #0000FF; specularColor: #AAAAFF; specularPower: 128\"> </bml-entity> <!-- A semi-transparent green box --> <bml-entity geometry=\"type: box\" position=\"2 1 -5\" material=\"type: standard; diffuseColor: green; alpha: 0.6\"> </bml-entity> <!-- A wireframe ground --> <bml-entity geometry=\"type: ground; subdivisions: 5\" position=\"0 0 -5\" material=\"type: standard; diffuseColor: grey; wireframe: true\"> </bml-entity> </bml-scene> Notes The material component requires a geometry component on the same entity to have a mesh to apply the material to. If the geometry component recreates its mesh (e.g., on type change), the material component will reapply the current material to the new mesh. Texture properties ( diffuseTexture , etc.) are defined in the schema but require specific loading logic within the component's update method, which is not yet implemented in the base version shown in previous steps. Changing material properties dynamically via setAttribute will update the appearance.","title":"Material"},{"location":"components/material/#component-reference-material","text":"The material component defines the surface appearance of an entity's mesh (created by the geometry component). It primarily uses Babylon.js's StandardMaterial .","title":"Component Reference: material"},{"location":"components/material/#attribute-syntax","text":"The material attribute uses the component/map string format. The type property determines the kind of material (currently only standard is fully supported). Other properties control visual aspects like color and texture. <!-- A simple red material --> <bml-entity material=\"type: standard; diffuseColor: red\"></bml-entity> <!-- A material with diffuse and emissive colors --> <bml-entity material=\"type: standard; diffuseColor: #00FF00; emissiveColor: #333333\"></bml-entity> <!-- A material using a texture (requires texture loading logic) --> <!-- <bml-entity material=\"type: standard; diffuseTexture: path/to/texture.jpg\"></bml-entity> -->","title":"Attribute Syntax"},{"location":"components/material/#common-properties","text":"Property Type Default Description type string 'standard' The type of material to create. Currently standard .","title":"Common Properties"},{"location":"components/material/#type-standard-properties","text":"These properties apply when type is standard (or omitted). They correspond to properties of Babylon.js's StandardMaterial . Property Type Default Description diffuseColor color #FFFFFF (White) The base color of the material under light. emissiveColor color #000000 (Black) Color emitted by the material, independent of light (makes it glow). specularColor color #FFFFFF (White) Color of highlights from light sources. ambientColor color #000000 (Black) Color of the material in ambient light (less commonly used). alpha number 1.0 Overall transparency (0 = fully transparent, 1 = fully opaque). specularPower number 64 Controls the sharpness/size of specular highlights. Higher is sharper. wireframe boolean false If true , renders the mesh as a wireframe instead of solid surfaces. backFaceCulling boolean true If true (default), hides the back faces of polygons for performance. Set to false for double-sided materials. diffuseTexture string (URL) null URL of the texture image for the base color. (Texture loading needs implementation) emissiveTexture string (URL) null URL of the texture for emissive color. (Texture loading needs implementation) ... (other StandardMaterial properties like bumpTexture, ambientTexture etc. could be added) Color Parsing: Color properties accept standard CSS color formats like #RRGGBB , #RGB , color names ( red , blue ), rgb(r,g,b) .","title":"type: standard Properties"},{"location":"components/material/#underlying-babylonjs-object","text":"This component creates and manages a BABYLON.StandardMaterial instance and applies it to the mesh created by the geometry component on the same entity.","title":"Underlying Babylon.js Object"},{"location":"components/material/#example","text":"<bml-scene> <!-- A shiny blue sphere --> <bml-entity geometry=\"type: sphere\" position=\"0 1 -5\" material=\"type: standard; diffuseColor: #0000FF; specularColor: #AAAAFF; specularPower: 128\"> </bml-entity> <!-- A semi-transparent green box --> <bml-entity geometry=\"type: box\" position=\"2 1 -5\" material=\"type: standard; diffuseColor: green; alpha: 0.6\"> </bml-entity> <!-- A wireframe ground --> <bml-entity geometry=\"type: ground; subdivisions: 5\" position=\"0 0 -5\" material=\"type: standard; diffuseColor: grey; wireframe: true\"> </bml-entity> </bml-scene>","title":"Example"},{"location":"components/material/#notes","text":"The material component requires a geometry component on the same entity to have a mesh to apply the material to. If the geometry component recreates its mesh (e.g., on type change), the material component will reapply the current material to the new mesh. Texture properties ( diffuseTexture , etc.) are defined in the schema but require specific loading logic within the component's update method, which is not yet implemented in the base version shown in previous steps. Changing material properties dynamically via setAttribute will update the appearance.","title":"Notes"},{"location":"components/position/","text":"Component Reference: position The position component controls the location of an entity within the 3D scene's coordinate system. Attribute Syntax The position attribute accepts a string representing a 3D vector. It can be specified in two ways: Component/Map String: Using x: , y: , z: keys. html <bml-entity position=\"x: 1; y: 2.5; z: -3\"></bml-entity> Direct Vector String: A space-separated string of three numbers (X Y Z). html <bml-entity position=\"1 2.5 -3\"></bml-entity> If any coordinate is omitted in the map string, it defaults to 0 . If the attribute is present but empty ( position=\"\" ), it defaults to 0 0 0 . Properties Property Type Default Description x number 0 Position along the horizontal axis y number 0 Position along the vertical axis z number 0 Position along the depth axis Underlying Babylon.js Property This component directly modifies the position property (a Vector3 ) of the entity's underlying Babylon.js TransformNode (or Mesh ). Example <bml-scene> <!-- Place a box 1 unit right, 2 units up, and 4 units back --> <bml-entity geometry=\"type: box\" position=\"x: 1; y: 2; z: -4\" material=\"type: standard; diffuseColor: orange\"> </bml-entity> <!-- Place a sphere using direct vector syntax --> <bml-entity geometry=\"type: sphere\" position=\"-2 0.5 -3\" material=\"type: standard; diffuseColor: cyan\"> </bml-entity> </bml-scene> Notes The position is relative to the entity's parent in the scene graph. If the entity is a direct child of <bml-scene> , the position is relative to the world origin (0, 0, 0). Changing the position attribute dynamically via JavaScript ( element.setAttribute('position', '...') ) will update the entity's position in the scene.","title":"Position"},{"location":"components/position/#component-reference-position","text":"The position component controls the location of an entity within the 3D scene's coordinate system.","title":"Component Reference: position"},{"location":"components/position/#attribute-syntax","text":"The position attribute accepts a string representing a 3D vector. It can be specified in two ways: Component/Map String: Using x: , y: , z: keys. html <bml-entity position=\"x: 1; y: 2.5; z: -3\"></bml-entity> Direct Vector String: A space-separated string of three numbers (X Y Z). html <bml-entity position=\"1 2.5 -3\"></bml-entity> If any coordinate is omitted in the map string, it defaults to 0 . If the attribute is present but empty ( position=\"\" ), it defaults to 0 0 0 .","title":"Attribute Syntax"},{"location":"components/position/#properties","text":"Property Type Default Description x number 0 Position along the horizontal axis y number 0 Position along the vertical axis z number 0 Position along the depth axis","title":"Properties"},{"location":"components/position/#underlying-babylonjs-property","text":"This component directly modifies the position property (a Vector3 ) of the entity's underlying Babylon.js TransformNode (or Mesh ).","title":"Underlying Babylon.js Property"},{"location":"components/position/#example","text":"<bml-scene> <!-- Place a box 1 unit right, 2 units up, and 4 units back --> <bml-entity geometry=\"type: box\" position=\"x: 1; y: 2; z: -4\" material=\"type: standard; diffuseColor: orange\"> </bml-entity> <!-- Place a sphere using direct vector syntax --> <bml-entity geometry=\"type: sphere\" position=\"-2 0.5 -3\" material=\"type: standard; diffuseColor: cyan\"> </bml-entity> </bml-scene>","title":"Example"},{"location":"components/position/#notes","text":"The position is relative to the entity's parent in the scene graph. If the entity is a direct child of <bml-scene> , the position is relative to the world origin (0, 0, 0). Changing the position attribute dynamically via JavaScript ( element.setAttribute('position', '...') ) will update the entity's position in the scene.","title":"Notes"},{"location":"components/rotation/","text":"Component Reference: rotation The rotation component controls the orientation of an entity in 3D space using Euler angles (degrees). Attribute Syntax The rotation attribute accepts a string representing Euler angles (in degrees). It can be specified in two ways: Component/Map String: Using x: , y: , z: keys. html <bml-entity rotation=\"x: 0; y: 45; z: 15\"></bml-entity> Direct Vector String: A space-separated string of three numbers (X Y Z degrees). html <bml-entity rotation=\"0 45 15\"></bml-entity> If any coordinate is omitted in the map string, it defaults to 0 . If the attribute is present but empty ( rotation=\"\" ), it defaults to 0 0 0 . Properties Property Type Default Description x number 0 Rotation around the X-axis (pitch), degrees. y number 0 Rotation around the Y-axis (yaw), degrees. z number 0 Rotation around the Z-axis (roll), degrees. Underlying Babylon.js Property This component modifies the rotation property (a Vector3 ) of the entity's underlying Babylon.js TransformNode (or Mesh ). Important: Babylon.js internally uses radians for rotation, but the rotation component schema handles the conversion from the degrees you provide in the HTML attribute to radians. Example <bml-scene> <!-- Rotate a box 45 degrees around the Y axis --> <bml-entity geometry=\"type: box\" position=\"0 1 -5\" rotation=\"0 45 0\" material=\"type: standard; diffuseColor: purple\"> </bml-entity> <!-- Rotate a cylinder using map syntax --> <bml-entity geometry=\"type: cylinder\" position=\"-2 1 -5\" rotation=\"x: 90; y: 0; z: 0\" <!-- Lay the cylinder on its side --> material=\"type: standard; diffuseColor: grey\"> </bml-entity> </bml-scene> Notes Rotations are applied in a specific order (typically Y, then X, then Z in Babylon.js default Euler order). The rotation is relative to the entity's parent's orientation. Changing the rotation attribute dynamically via JavaScript ( element.setAttribute('rotation', '...') ) will update the entity's orientation in the scene. For complex rotations or avoiding gimbal lock issues, Babylon.js also supports Quaternions ( rotationQuaternion ), but this component currently focuses on the more intuitive Euler angles.","title":"Rotation"},{"location":"components/rotation/#component-reference-rotation","text":"The rotation component controls the orientation of an entity in 3D space using Euler angles (degrees).","title":"Component Reference: rotation"},{"location":"components/rotation/#attribute-syntax","text":"The rotation attribute accepts a string representing Euler angles (in degrees). It can be specified in two ways: Component/Map String: Using x: , y: , z: keys. html <bml-entity rotation=\"x: 0; y: 45; z: 15\"></bml-entity> Direct Vector String: A space-separated string of three numbers (X Y Z degrees). html <bml-entity rotation=\"0 45 15\"></bml-entity> If any coordinate is omitted in the map string, it defaults to 0 . If the attribute is present but empty ( rotation=\"\" ), it defaults to 0 0 0 .","title":"Attribute Syntax"},{"location":"components/rotation/#properties","text":"Property Type Default Description x number 0 Rotation around the X-axis (pitch), degrees. y number 0 Rotation around the Y-axis (yaw), degrees. z number 0 Rotation around the Z-axis (roll), degrees.","title":"Properties"},{"location":"components/rotation/#underlying-babylonjs-property","text":"This component modifies the rotation property (a Vector3 ) of the entity's underlying Babylon.js TransformNode (or Mesh ). Important: Babylon.js internally uses radians for rotation, but the rotation component schema handles the conversion from the degrees you provide in the HTML attribute to radians.","title":"Underlying Babylon.js Property"},{"location":"components/rotation/#example","text":"<bml-scene> <!-- Rotate a box 45 degrees around the Y axis --> <bml-entity geometry=\"type: box\" position=\"0 1 -5\" rotation=\"0 45 0\" material=\"type: standard; diffuseColor: purple\"> </bml-entity> <!-- Rotate a cylinder using map syntax --> <bml-entity geometry=\"type: cylinder\" position=\"-2 1 -5\" rotation=\"x: 90; y: 0; z: 0\" <!-- Lay the cylinder on its side --> material=\"type: standard; diffuseColor: grey\"> </bml-entity> </bml-scene>","title":"Example"},{"location":"components/rotation/#notes","text":"Rotations are applied in a specific order (typically Y, then X, then Z in Babylon.js default Euler order). The rotation is relative to the entity's parent's orientation. Changing the rotation attribute dynamically via JavaScript ( element.setAttribute('rotation', '...') ) will update the entity's orientation in the scene. For complex rotations or avoiding gimbal lock issues, Babylon.js also supports Quaternions ( rotationQuaternion ), but this component currently focuses on the more intuitive Euler angles.","title":"Notes"},{"location":"components/scale/","text":"Component Reference: scale The scale component controls the size of an entity along the X, Y, and Z axes. Attribute Syntax The scale attribute accepts a string representing a 3D vector. It can be specified in two ways: Component/Map String: Using x: , y: , z: keys. html <bml-entity scale=\"x: 1; y: 2; z: 0.5\"></bml-entity> Direct Vector String: A space-separated string of three numbers (X Y Z scale factors). html <bml-entity scale=\"1 2 0.5\"></bml-entity> If any coordinate is omitted in the map string, it defaults to 1 . If the attribute is present but empty ( scale=\"\" ), it defaults to 1 1 1 . Properties Property Type Default Description x number 1 Scaling factor along the X-axis. y number 1 Scaling factor along the Y-axis. z number 1 Scaling factor along the Z-axis. Underlying Babylon.js Property This component directly modifies the scaling property (a Vector3 ) of the entity's underlying Babylon.js TransformNode (or Mesh ). Example <bml-scene> <!-- Make a box twice as tall --> <bml-entity geometry=\"type: box\" position=\"0 1 -5\" scale=\"x: 1; y: 2; z: 1\" material=\"type: standard; diffuseColor: red\"> </bml-entity> <!-- Make a sphere uniformly smaller using direct vector syntax --> <bml-entity geometry=\"type: sphere\" position=\"-2 0.5 -5\" scale=\"0.5 0.5 0.5\" material=\"type: standard; diffuseColor: blue\"> </bml-entity> <!-- Make a ground plane wider --> <bml-entity geometry=\"type: ground\" position=\"0 0 -5\" scale=\"2 1 1\" <!-- Scale X by 2, Y and Z remain 1 --> material=\"type: standard; diffuseColor: green\"> </bml-entity> </bml-scene> Notes A scale factor of 1 means original size, < 1 means smaller, > 1 means larger. Scaling is applied relative to the entity's local origin. Scaling applied to a parent entity also affects its children. Changing the scale attribute dynamically via JavaScript ( element.setAttribute('scale', '...') ) will update the entity's scale in the scene.","title":"Scale"},{"location":"components/scale/#component-reference-scale","text":"The scale component controls the size of an entity along the X, Y, and Z axes.","title":"Component Reference: scale"},{"location":"components/scale/#attribute-syntax","text":"The scale attribute accepts a string representing a 3D vector. It can be specified in two ways: Component/Map String: Using x: , y: , z: keys. html <bml-entity scale=\"x: 1; y: 2; z: 0.5\"></bml-entity> Direct Vector String: A space-separated string of three numbers (X Y Z scale factors). html <bml-entity scale=\"1 2 0.5\"></bml-entity> If any coordinate is omitted in the map string, it defaults to 1 . If the attribute is present but empty ( scale=\"\" ), it defaults to 1 1 1 .","title":"Attribute Syntax"},{"location":"components/scale/#properties","text":"Property Type Default Description x number 1 Scaling factor along the X-axis. y number 1 Scaling factor along the Y-axis. z number 1 Scaling factor along the Z-axis.","title":"Properties"},{"location":"components/scale/#underlying-babylonjs-property","text":"This component directly modifies the scaling property (a Vector3 ) of the entity's underlying Babylon.js TransformNode (or Mesh ).","title":"Underlying Babylon.js Property"},{"location":"components/scale/#example","text":"<bml-scene> <!-- Make a box twice as tall --> <bml-entity geometry=\"type: box\" position=\"0 1 -5\" scale=\"x: 1; y: 2; z: 1\" material=\"type: standard; diffuseColor: red\"> </bml-entity> <!-- Make a sphere uniformly smaller using direct vector syntax --> <bml-entity geometry=\"type: sphere\" position=\"-2 0.5 -5\" scale=\"0.5 0.5 0.5\" material=\"type: standard; diffuseColor: blue\"> </bml-entity> <!-- Make a ground plane wider --> <bml-entity geometry=\"type: ground\" position=\"0 0 -5\" scale=\"2 1 1\" <!-- Scale X by 2, Y and Z remain 1 --> material=\"type: standard; diffuseColor: green\"> </bml-entity> </bml-scene>","title":"Example"},{"location":"components/scale/#notes","text":"A scale factor of 1 means original size, < 1 means smaller, > 1 means larger. Scaling is applied relative to the entity's local origin. Scaling applied to a parent entity also affects its children. Changing the scale attribute dynamically via JavaScript ( element.setAttribute('scale', '...') ) will update the entity's scale in the scene.","title":"Notes"},{"location":"concepts/components/","text":"Core Concepts: Components Components are the primary way to attach data and behavior to <bml-entity> elements in BabylonML. They are defined using HTML attributes and manage specific aspects of the entity's corresponding Babylon.js node(s). Purpose Encapsulation: Each component focuses on a single aspect (e.g., position, geometry, material, light, custom behavior). Reusability: Components can be applied to any entity. Declarative Approach: Define an entity's properties directly in HTML using component attributes. Extensibility: You can register custom components to add new functionality. Defining Components Components are attached to <bml-entity> elements via attributes. The name of the attribute corresponds to the registered component name. <bml-entity position=\"x: 0; y: 1; z: -5\" <!-- Position component --> geometry=\"type: box; size: 2\" <!-- Geometry component --> material=\"type: standard; diffuseColor: yellow\" <!-- Material component --> > </bml-entity> Component Schema and Parsing Schema: Each component defines a schema that specifies the expected data structure and default values for its properties. This helps with parsing and validation. BabylonML currently supports simple types ( string , number , boolean ) and a map type for key-value string parsing (like position or geometry ). Parsing: The framework uses parsers (like parseVector3 , parseColor3 , parseObjectString found in src/core/parsers.js ) to convert the attribute string value into a JavaScript object or value based on the component's schema. Data Object: The parsed attribute value is passed as the data object to the component's lifecycle methods ( init , update , remove ). Component Lifecycle Methods When a component is registered, it provides an object containing lifecycle methods: schema (Required): Defines the expected data structure and defaults. javascript schema: { type: 'map', // or 'string', 'number', 'vec3', etc. default: { x: 0, y: 0, z: 0 } // Default value if attribute is empty or missing properties } init(data) (Optional): Called once when the component is first attached to the entity and the entity is connected to the DOM. Use this for one-time setup related to the component. data contains the initial parsed attribute value. update(data, oldData) (Optional): Called initially after init and subsequently whenever the component's corresponding attribute value changes on the HTML element. data is the new parsed value, oldData is the previous value. Use this to apply changes to the Babylon.js scene based on the new data. remove(data) (Optional): Called when the component is detached from the entity (e.g., the attribute is removed) or when the entity itself is removed from the DOM. Use this for cleanup, like disposing of Babylon.js objects created by the component. data contains the last known parsed value. this Context: Inside these lifecycle methods, this refers to the <bml-entity> HTML element instance the component is attached to. This allows access to this.babylonNode (the entity's TransformNode/Mesh) and this.sceneElement (the parent <bml-scene> ). Component Manager The ComponentManager (in src/core/ComponentManager.js ) is a central registry and handler for components: Registration: ComponentManager.registerComponent(name, definition) is used to register a new component type. Lifecycle Invocation: It hooks into the entity's lifecycle ( connectedCallback , attributeChangedCallback , disconnectedCallback ) to call the appropriate init , update , or remove methods on the relevant components. Attribute Observation: It provides the list of all registered component attribute names to BmlEntity.observedAttributes so the browser knows which attribute changes to monitor. Parsing: It uses the component's schema and the core parsers to handle attribute string conversion. Example: Position Component (Simplified) // Simplified structure - see src/components/position.js for full example ComponentManager.registerComponent('position', { schema: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }, // Expects parseVector3 update(data) { // 'this' is the <bml-entity> element if (this.babylonNode) { this.babylonNode.position.set(data.x, data.y, data.z); } } // No init or remove needed for simple position updates }); This component system provides a structured way to extend BabylonML's capabilities declaratively through HTML attributes.","title":"Components"},{"location":"concepts/components/#core-concepts-components","text":"Components are the primary way to attach data and behavior to <bml-entity> elements in BabylonML. They are defined using HTML attributes and manage specific aspects of the entity's corresponding Babylon.js node(s).","title":"Core Concepts: Components"},{"location":"concepts/components/#purpose","text":"Encapsulation: Each component focuses on a single aspect (e.g., position, geometry, material, light, custom behavior). Reusability: Components can be applied to any entity. Declarative Approach: Define an entity's properties directly in HTML using component attributes. Extensibility: You can register custom components to add new functionality.","title":"Purpose"},{"location":"concepts/components/#defining-components","text":"Components are attached to <bml-entity> elements via attributes. The name of the attribute corresponds to the registered component name. <bml-entity position=\"x: 0; y: 1; z: -5\" <!-- Position component --> geometry=\"type: box; size: 2\" <!-- Geometry component --> material=\"type: standard; diffuseColor: yellow\" <!-- Material component --> > </bml-entity>","title":"Defining Components"},{"location":"concepts/components/#component-schema-and-parsing","text":"Schema: Each component defines a schema that specifies the expected data structure and default values for its properties. This helps with parsing and validation. BabylonML currently supports simple types ( string , number , boolean ) and a map type for key-value string parsing (like position or geometry ). Parsing: The framework uses parsers (like parseVector3 , parseColor3 , parseObjectString found in src/core/parsers.js ) to convert the attribute string value into a JavaScript object or value based on the component's schema. Data Object: The parsed attribute value is passed as the data object to the component's lifecycle methods ( init , update , remove ).","title":"Component Schema and Parsing"},{"location":"concepts/components/#component-lifecycle-methods","text":"When a component is registered, it provides an object containing lifecycle methods: schema (Required): Defines the expected data structure and defaults. javascript schema: { type: 'map', // or 'string', 'number', 'vec3', etc. default: { x: 0, y: 0, z: 0 } // Default value if attribute is empty or missing properties } init(data) (Optional): Called once when the component is first attached to the entity and the entity is connected to the DOM. Use this for one-time setup related to the component. data contains the initial parsed attribute value. update(data, oldData) (Optional): Called initially after init and subsequently whenever the component's corresponding attribute value changes on the HTML element. data is the new parsed value, oldData is the previous value. Use this to apply changes to the Babylon.js scene based on the new data. remove(data) (Optional): Called when the component is detached from the entity (e.g., the attribute is removed) or when the entity itself is removed from the DOM. Use this for cleanup, like disposing of Babylon.js objects created by the component. data contains the last known parsed value. this Context: Inside these lifecycle methods, this refers to the <bml-entity> HTML element instance the component is attached to. This allows access to this.babylonNode (the entity's TransformNode/Mesh) and this.sceneElement (the parent <bml-scene> ).","title":"Component Lifecycle Methods"},{"location":"concepts/components/#component-manager","text":"The ComponentManager (in src/core/ComponentManager.js ) is a central registry and handler for components: Registration: ComponentManager.registerComponent(name, definition) is used to register a new component type. Lifecycle Invocation: It hooks into the entity's lifecycle ( connectedCallback , attributeChangedCallback , disconnectedCallback ) to call the appropriate init , update , or remove methods on the relevant components. Attribute Observation: It provides the list of all registered component attribute names to BmlEntity.observedAttributes so the browser knows which attribute changes to monitor. Parsing: It uses the component's schema and the core parsers to handle attribute string conversion.","title":"Component Manager"},{"location":"concepts/components/#example-position-component-simplified","text":"// Simplified structure - see src/components/position.js for full example ComponentManager.registerComponent('position', { schema: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }, // Expects parseVector3 update(data) { // 'this' is the <bml-entity> element if (this.babylonNode) { this.babylonNode.position.set(data.x, data.y, data.z); } } // No init or remove needed for simple position updates }); This component system provides a structured way to extend BabylonML's capabilities declaratively through HTML attributes.","title":"Example: Position Component (Simplified)"},{"location":"concepts/entity/","text":"Core Concepts: <bml-entity> The <bml-entity> element is the fundamental building block for objects within your BabylonML scene. It represents a node in the 3D scene graph and serves as a container for components that define its appearance, position, and behavior. Purpose Scene Graph Node: Each <bml-entity> corresponds to a BABYLON.TransformNode in the underlying Babylon.js scene graph by default. A TransformNode is a lightweight node primarily used for positioning, rotating, and scaling. Component Host: Entities don't do much on their own. Their functionality comes from attaching components via HTML attributes (e.g., position , geometry , material ). Hierarchy: Entities can be nested inside other entities to create parent-child relationships, mirroring the scene graph structure. Transformations (position, rotation, scale) applied to a parent entity affect its children. Lifecycle Management: The <bml-entity> custom element manages the creation, update, and disposal of its corresponding Babylon.js node and attached components when the element is added to, modified within, or removed from the DOM. Basic Usage <bml-scene> <!-- An entity with position, geometry, and material components --> <bml-entity id=\"my-sphere\" position=\"1 0.5 -2\" geometry=\"type: sphere; diameter: 1\" material=\"type: standard; diffuseColor: blue\"> </bml-entity> <!-- An empty entity acting as a parent/group --> <bml-entity id=\"pivot-point\" position=\"0 2 0\" rotation=\"0 30 0\"> <!-- A child entity, its position is relative to the parent --> <bml-entity id=\"child-box\" position=\"1 0 0\" geometry=\"type: box; size: 0.5\" material=\"type: standard; diffuseColor: green\"> </bml-entity> </bml-entity> </bml-scene> Components Components are defined using attributes on the <bml-entity> tag. The framework parses these attributes and manages the underlying Babylon.js logic. Attribute Syntax: Components typically use a key-value string format, separated by semicolons ( ; ) and colons ( : ). Example: position=\"x: 1; y: 2; z: 3\" or material=\"type: standard; diffuseColor: #FF0000\" . The specific properties depend on the component. See the Component Reference section for details on each component. Dynamic Updates: Changing an observed attribute on the <bml-entity> element in the DOM (e.g., via JavaScript setAttribute ) will trigger the corresponding component's update logic. Lifecycle Callbacks (Internal) The BmlEntity custom element uses standard lifecycle callbacks: connectedCallback() : Called when the entity is added to the DOM. This is where the Babylon.js TransformNode is created, parented correctly in the scene graph, and initial components are initialized based on existing attributes. disconnectedCallback() : Called when the entity is removed from the DOM. This triggers the removal of all attached components and the disposal of the corresponding Babylon.js node, cleaning up resources. attributeChangedCallback(name, oldValue, newValue) : Called when an attribute listed in observedAttributes changes. This delegates the update logic to the ComponentManager , which finds the relevant component and calls its update method. observedAttributes For attributeChangedCallback to function, the custom element must define which attributes it cares about. BmlEntity dynamically gets this list from the ComponentManager , ensuring that any registered component attribute will trigger updates when changed. The id attribute is also always observed. Accessing the Babylon.js Node While the goal of BabylonML is to abstract away direct Babylon.js interaction, you can access the underlying node if needed: const entityElement = document.getElementById('my-sphere'); if (entityElement && entityElement.babylonNode) { const transformNode = entityElement.babylonNode; // Interact with the Babylon.js TransformNode directly // transformNode.scaling.y = 2; } Note: Some components, like geometry , might create a Mesh instead of just using the default TransformNode . The babylonNode property might reference this Mesh , or the Mesh might be a child of the entity's main TransformNode . Check the specific component documentation for details. Currently, the geometry mesh is created as a child of the entity's TransformNode .","title":"Entity (`<bml-entity>`)"},{"location":"concepts/entity/#core-concepts-bml-entity","text":"The <bml-entity> element is the fundamental building block for objects within your BabylonML scene. It represents a node in the 3D scene graph and serves as a container for components that define its appearance, position, and behavior.","title":"Core Concepts: &lt;bml-entity&gt;"},{"location":"concepts/entity/#purpose","text":"Scene Graph Node: Each <bml-entity> corresponds to a BABYLON.TransformNode in the underlying Babylon.js scene graph by default. A TransformNode is a lightweight node primarily used for positioning, rotating, and scaling. Component Host: Entities don't do much on their own. Their functionality comes from attaching components via HTML attributes (e.g., position , geometry , material ). Hierarchy: Entities can be nested inside other entities to create parent-child relationships, mirroring the scene graph structure. Transformations (position, rotation, scale) applied to a parent entity affect its children. Lifecycle Management: The <bml-entity> custom element manages the creation, update, and disposal of its corresponding Babylon.js node and attached components when the element is added to, modified within, or removed from the DOM.","title":"Purpose"},{"location":"concepts/entity/#basic-usage","text":"<bml-scene> <!-- An entity with position, geometry, and material components --> <bml-entity id=\"my-sphere\" position=\"1 0.5 -2\" geometry=\"type: sphere; diameter: 1\" material=\"type: standard; diffuseColor: blue\"> </bml-entity> <!-- An empty entity acting as a parent/group --> <bml-entity id=\"pivot-point\" position=\"0 2 0\" rotation=\"0 30 0\"> <!-- A child entity, its position is relative to the parent --> <bml-entity id=\"child-box\" position=\"1 0 0\" geometry=\"type: box; size: 0.5\" material=\"type: standard; diffuseColor: green\"> </bml-entity> </bml-entity> </bml-scene>","title":"Basic Usage"},{"location":"concepts/entity/#components","text":"Components are defined using attributes on the <bml-entity> tag. The framework parses these attributes and manages the underlying Babylon.js logic. Attribute Syntax: Components typically use a key-value string format, separated by semicolons ( ; ) and colons ( : ). Example: position=\"x: 1; y: 2; z: 3\" or material=\"type: standard; diffuseColor: #FF0000\" . The specific properties depend on the component. See the Component Reference section for details on each component. Dynamic Updates: Changing an observed attribute on the <bml-entity> element in the DOM (e.g., via JavaScript setAttribute ) will trigger the corresponding component's update logic.","title":"Components"},{"location":"concepts/entity/#lifecycle-callbacks-internal","text":"The BmlEntity custom element uses standard lifecycle callbacks: connectedCallback() : Called when the entity is added to the DOM. This is where the Babylon.js TransformNode is created, parented correctly in the scene graph, and initial components are initialized based on existing attributes. disconnectedCallback() : Called when the entity is removed from the DOM. This triggers the removal of all attached components and the disposal of the corresponding Babylon.js node, cleaning up resources. attributeChangedCallback(name, oldValue, newValue) : Called when an attribute listed in observedAttributes changes. This delegates the update logic to the ComponentManager , which finds the relevant component and calls its update method.","title":"Lifecycle Callbacks (Internal)"},{"location":"concepts/entity/#observedattributes","text":"For attributeChangedCallback to function, the custom element must define which attributes it cares about. BmlEntity dynamically gets this list from the ComponentManager , ensuring that any registered component attribute will trigger updates when changed. The id attribute is also always observed.","title":"observedAttributes"},{"location":"concepts/entity/#accessing-the-babylonjs-node","text":"While the goal of BabylonML is to abstract away direct Babylon.js interaction, you can access the underlying node if needed: const entityElement = document.getElementById('my-sphere'); if (entityElement && entityElement.babylonNode) { const transformNode = entityElement.babylonNode; // Interact with the Babylon.js TransformNode directly // transformNode.scaling.y = 2; } Note: Some components, like geometry , might create a Mesh instead of just using the default TransformNode . The babylonNode property might reference this Mesh , or the Mesh might be a child of the entity's main TransformNode . Check the specific component documentation for details. Currently, the geometry mesh is created as a child of the entity's TransformNode .","title":"Accessing the Babylon.js Node"},{"location":"concepts/scene/","text":"Core Concepts: <bml-scene> The <bml-scene> element is the heart of any BabylonML application. It acts as the root container for your 3D world and handles the initialization of the underlying Babylon.js engine and scene. Purpose Initializes Babylon.js: Automatically creates the Engine and Scene objects required by Babylon.js. Creates a Canvas: If no <canvas> element is found inside <bml-scene> , it will create one automatically to render the scene. Provides Defaults: Sets up a default camera and a default light source if none are explicitly defined within the scene, making it easy to get something visible quickly. Manages Scene Lifecycle: Starts the Babylon.js render loop to continuously draw the scene. Entity Management: Uses a MutationObserver to detect when <bml-entity> elements are added or removed, managing their corresponding Babylon.js nodes. Provides Context: Makes the Babylon.js Scene object available to descendant <bml-entity> elements and their components. Basic Usage <bml-scene> <!-- Entities go here --> <bml-entity geometry=\"type: box\"></bml-entity> </bml-scene> This minimal example will: 1. Create a Babylon.js Engine and Scene. 2. Create a <canvas> element filling the <bml-scene> container. 3. Add a default camera (a FreeCamera ). 4. Add a default light (a HemisphericLight ). 5. Start rendering the scene (which will initially contain the box entity). Default Camera and Light To make it easy to get started, <bml-scene> automatically creates a default camera and light source under specific conditions: Default Camera: If no element within the <bml-scene> has a camera attribute (e.g., <bml-entity camera=\"...\"> ), a BABYLON.FreeCamera named default_camera is created. It's positioned at (0, 1.6, -5) and has mouse/touch controls attached to the canvas. Default Light: If no element within the <bml-scene> has a light attribute (e.g., <bml-entity light=\"...\"> ), a BABYLON.HemisphericLight named default_light is created, providing basic ambient illumination from above. Overriding Defaults: If you add any element with a camera attribute, the default camera will not be created. You are then responsible for defining your own camera(s) using the camera component . If you add any element with a light attribute, the default light will not be created. Important Note: As of the current version, there is no built-in light component. Adding a light attribute only prevents the default light; it does not automatically create a new light source based on the attribute value. To add specific lights (PointLight, SpotLight, etc.), you currently need to use custom JavaScript that interacts with the Babylon.js scene (e.g., within the bml-scene-ready event). A dedicated light component is planned for future development. Styling It's crucial to give <bml-scene> dimensions using CSS, otherwise the canvas might not be visible or have zero size. A common approach is to make it fill the viewport: html, body { margin: 0; padding: 0; overflow: hidden; /* Prevent scrollbars */ height: 100%; width: 100%; } bml-scene { width: 100vw; /* Viewport width */ height: 100vh; /* Viewport height */ display: block; /* Ensure it behaves like a block element */ } /* Optional: Ensure canvas itself doesn't cause layout issues */ canvas { display: block; } Attributes xr : Enables WebXR support for the scene. This attribute initializes the Babylon.js WebXRDefaultExperience helper, providing a quick way to add VR or AR capabilities. xr=\"vr\" : Initializes the scene for Virtual Reality (VR). Requires a VR-capable headset and browser. xr=\"ar\" : Initializes the scene for Augmented Reality (AR). Requires an AR-capable device (usually mobile) and browser, and often requires the page to be served over HTTPS. xr or xr=\"true\" : Initializes a default XR experience, typically VR. If the attribute is omitted, XR support is disabled. Example: ```html ``` Note: WebXR support is dependent on the user's browser and hardware capabilities. The framework will attempt to initialize the requested mode, but it may fail if the requirements are not met. Check the browser console for messages regarding XR initialization status. Live VR Example: View VR Scene Live AR Example: View AR Scene (Requires compatible device/browser) Events bml-scene-ready : Fired when the Babylon.js Engine and Scene have been initialized, the default camera/light (if needed) are set up, and the render loop has started. The event detail contains references to the Babylon.js scene and engine . javascript const sceneEl = document.querySelector('bml-scene'); sceneEl.addEventListener('bml-scene-ready', (event) => { console.log('Scene is ready!', event.detail); const babylonScene = event.detail.scene; const babylonEngine = event.detail.engine; // You can now interact with the Babylon.js objects directly }); Internal Details The <bml-scene> element creates and manages instances of BABYLON.Engine and BABYLON.Scene . It uses a MutationObserver to watch for changes to its direct children and descendants to manage <bml-entity> lifecycles.","title":"Scene (`<bml-scene>`)"},{"location":"concepts/scene/#core-concepts-bml-scene","text":"The <bml-scene> element is the heart of any BabylonML application. It acts as the root container for your 3D world and handles the initialization of the underlying Babylon.js engine and scene.","title":"Core Concepts: &lt;bml-scene&gt;"},{"location":"concepts/scene/#purpose","text":"Initializes Babylon.js: Automatically creates the Engine and Scene objects required by Babylon.js. Creates a Canvas: If no <canvas> element is found inside <bml-scene> , it will create one automatically to render the scene. Provides Defaults: Sets up a default camera and a default light source if none are explicitly defined within the scene, making it easy to get something visible quickly. Manages Scene Lifecycle: Starts the Babylon.js render loop to continuously draw the scene. Entity Management: Uses a MutationObserver to detect when <bml-entity> elements are added or removed, managing their corresponding Babylon.js nodes. Provides Context: Makes the Babylon.js Scene object available to descendant <bml-entity> elements and their components.","title":"Purpose"},{"location":"concepts/scene/#basic-usage","text":"<bml-scene> <!-- Entities go here --> <bml-entity geometry=\"type: box\"></bml-entity> </bml-scene> This minimal example will: 1. Create a Babylon.js Engine and Scene. 2. Create a <canvas> element filling the <bml-scene> container. 3. Add a default camera (a FreeCamera ). 4. Add a default light (a HemisphericLight ). 5. Start rendering the scene (which will initially contain the box entity).","title":"Basic Usage"},{"location":"concepts/scene/#default-camera-and-light","text":"To make it easy to get started, <bml-scene> automatically creates a default camera and light source under specific conditions: Default Camera: If no element within the <bml-scene> has a camera attribute (e.g., <bml-entity camera=\"...\"> ), a BABYLON.FreeCamera named default_camera is created. It's positioned at (0, 1.6, -5) and has mouse/touch controls attached to the canvas. Default Light: If no element within the <bml-scene> has a light attribute (e.g., <bml-entity light=\"...\"> ), a BABYLON.HemisphericLight named default_light is created, providing basic ambient illumination from above. Overriding Defaults: If you add any element with a camera attribute, the default camera will not be created. You are then responsible for defining your own camera(s) using the camera component . If you add any element with a light attribute, the default light will not be created. Important Note: As of the current version, there is no built-in light component. Adding a light attribute only prevents the default light; it does not automatically create a new light source based on the attribute value. To add specific lights (PointLight, SpotLight, etc.), you currently need to use custom JavaScript that interacts with the Babylon.js scene (e.g., within the bml-scene-ready event). A dedicated light component is planned for future development.","title":"Default Camera and Light"},{"location":"concepts/scene/#styling","text":"It's crucial to give <bml-scene> dimensions using CSS, otherwise the canvas might not be visible or have zero size. A common approach is to make it fill the viewport: html, body { margin: 0; padding: 0; overflow: hidden; /* Prevent scrollbars */ height: 100%; width: 100%; } bml-scene { width: 100vw; /* Viewport width */ height: 100vh; /* Viewport height */ display: block; /* Ensure it behaves like a block element */ } /* Optional: Ensure canvas itself doesn't cause layout issues */ canvas { display: block; }","title":"Styling"},{"location":"concepts/scene/#attributes","text":"xr : Enables WebXR support for the scene. This attribute initializes the Babylon.js WebXRDefaultExperience helper, providing a quick way to add VR or AR capabilities. xr=\"vr\" : Initializes the scene for Virtual Reality (VR). Requires a VR-capable headset and browser. xr=\"ar\" : Initializes the scene for Augmented Reality (AR). Requires an AR-capable device (usually mobile) and browser, and often requires the page to be served over HTTPS. xr or xr=\"true\" : Initializes a default XR experience, typically VR. If the attribute is omitted, XR support is disabled. Example: ```html ``` Note: WebXR support is dependent on the user's browser and hardware capabilities. The framework will attempt to initialize the requested mode, but it may fail if the requirements are not met. Check the browser console for messages regarding XR initialization status. Live VR Example: View VR Scene Live AR Example: View AR Scene (Requires compatible device/browser)","title":"Attributes"},{"location":"concepts/scene/#events","text":"bml-scene-ready : Fired when the Babylon.js Engine and Scene have been initialized, the default camera/light (if needed) are set up, and the render loop has started. The event detail contains references to the Babylon.js scene and engine . javascript const sceneEl = document.querySelector('bml-scene'); sceneEl.addEventListener('bml-scene-ready', (event) => { console.log('Scene is ready!', event.detail); const babylonScene = event.detail.scene; const babylonEngine = event.detail.engine; // You can now interact with the Babylon.js objects directly });","title":"Events"},{"location":"concepts/scene/#internal-details","text":"The <bml-scene> element creates and manages instances of BABYLON.Engine and BABYLON.Scene . It uses a MutationObserver to watch for changes to its direct children and descendants to manage <bml-entity> lifecycles.","title":"Internal Details"}]}